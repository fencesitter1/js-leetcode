
```toc
```

# 本地环境搭建
## 自定义代码片段
如果你想在 VSCode 中避免每次都写相同的起始代码，你可以创建一个代码片段（Snippet）。代码片段是一小段预定义的代码，通过简单的快捷键或者其他触发方式就可以插入到你的代码中。
在 VSCode 中，你可以创建自定义的代码片段。以下是一个简单的例子，演示如何创建一个代码片段来导入 readline-sync 和设置默认选项：
1. 打开 VSCode，进入你的项目。
2. 在左侧资源管理器中，右键点击 `.vscode` 文件夹（如果没有，请新建一个），然后选择 "New File"，创建一个名为 `code-snippets.json` 的文件。
3. 在 `code-snippets.json` 文件中添加以下内容：

```json
{
  "Readline Setup": {
    "prefix": ["readline", "setup"],
    "body": [
      "var __readline = require(\"readline-sync\");",
      "__readline.setDefaultOptions({ prompt: \"\" });",
      "var readline = __readline.prompt;"
    ],
    "description": "Setup readline-sync"
  }
}
```
这个 JSON 文件定义了一个名为 "Readline Setup" 的代码片段。当你在代码中输入 `readline setup` 时，按下 `Tab` 键，它会自动展开为你想要的 readline-sync 设置代码。

4. 保存 `code-snippets.json` 文件。
现在，当你在你的代码中输入 `readline setup`，然后按下 `Tab` 键，就会自动生成 readline-sync 设置的代码。

# 数组
## 二分查找
```js
var search = function(nums, target) {
    // right是数组最后一个数的下标，num[right]在查找范围内，是左闭右闭区间
    let mid, left = 0, right = nums.length - 1;
    // 当left=right时，由于nums[right]在查找范围内，所以要包括此情况
    while (left <= right) {
        // 位运算 + 防止大数溢出
        mid = left + ((right - left) >> 1);
        // 如果中间数大于目标值，要把中间数排除查找范围，所以右边界更新为mid-1；如果右边界更新为mid，那中间数还在下次查找范围内
        if (nums[mid] > target) {
            right = mid - 1;  // 去左面闭区间寻找
        } else if (nums[mid] < target) {
            left = mid + 1;   // 去右面闭区间寻找
        } else {
            return mid;
        }
    }
    return -1;
};
```
## 移除元素
[移除元素](https://leetcode.cn/problems/remove-element/solutions/)
1. 思路:快慢指针
```js
var removeElement = function(nums, val) {
    let slow=0;
    for(let fast=0;fast<nums.length;fast++){
        if(nums[fast]!=val){
            nums[slow]=nums[fast];
            slow++;
        }
    }
    return slow;
};
```
## 长度最小的子数组
### 题目
[长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)
### 思路 :
	滑动窗口法
```js
var minSubArrayLen = function(target, nums) {
    let start, end
    start = end = 0
    let sum = 0
    let len = nums.length
    let ans = Infinity
    
    while(end < len){
        sum += nums[end];
        while (sum >= target) {
            ans = Math.min(ans, end - start + 1);
            sum -= nums[start];
            start++;//左指针滑动
        }
        end++;
    }
    return ans === Infinity ? 0 : ans
};
```
## 螺旋矩阵 II
[螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/solutions/659084/ru-guo-ni-yuan-yi-yi-ceng-yi-ceng-yi-cen-cm9h/)
### 思路:
我们开始的思路都是一样的按照从左到右从上到下从右到左从下到上的顺序遍历这个二维数组，但是边界条件很难把控,导致晕头转向
我们可以发现在每遍历完一条边后边界都会收缩,如第一次循环的起点是从(0,0)开始的,第二次的话就会从(1,1)开始,当边界收缩到上边界>下边界或左边界>右边界时,我们就可以说我们将这个数组遍历完了
所以我们可以设置 t(上边界)、r(右边界)、b(下边界)、l(左边界),每次遍历完一条边后向内收缩 t++ / r-- / b-- / l++,当收缩到 t > b 或 l > r 时则说明我们完成了一整个矩阵的循环
此思路同样适用于54题

```js
var generateMatrix = function (n) {
  const matrix = new Array(n);
  for (let i = 0; i < n; i++) {
    matrix[i] = new Array(n);
  }
  let num = 1;
  let left = 0;
  let right = n - 1;
  let top = 0;
  let bottom = n - 1;
  while (left <= right && top <= bottom) {
  //while(num<=n*n)
    for (i = left; i <= right; i++) {
      matrix[top][i] = num;
      num++;
    }
    top++;

    for (i = top; i <= bottom; i++) {
      matrix[i][right] = num;
      num++;
    }
    right--;
    for (i = right; i >= left; i--) {
      matrix[bottom][i] = num++;
    }
    bottom--;
    for (i = bottom; i >= top; i--) {
      matrix[i][left] = num++;
    }
    left++;
  }
  return matrix;
};
```
### JS 二维数组

```js
let arr=new Array(n).fill(0).map(() => new Array(n).fill(0))
```

# 链表
## 移除链表元素
[203.移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)
```js
var removeElements = function(head, val) {
  const dummy=new ListNode(0);
  dummy.next=head;
  let cur=dummy;
  while(cur.next!=null){
    cur.next.val==val ? cur.next=cur.next.next:cur=cur.next
  }

  return dummy.next
  };
```
## 设计链表
- 时间：2023-11-26
### 法一:双指针法
```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
 let temp=null;pre=null;cur=head;
 while(cur){
     temp=cur.next;
     cur.next=pre;
     pre=cur;
     cur=temp;
 }
 return pre;
};
```
## 两两交换链表中的节点
[leetcode24.](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)
```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    let dummy=new ListNode(0,head);//定义一个虚拟空节点
    let cur=dummy;
    while(cur.next&&cur.next.next){
        let n1=cur.next;
        let n2=cur.next.next;
        cur.next=n2;
        n1.next=n2.next;
        n2.next=n1;
        cur=n1;
    }
    return dummy.next;
}
```

## 19.删除链表的倒数第 N 个节点
[leetcode19](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)
### 快慢指针(双指针)
需要注意的是 n ，快慢指针间隔为 n+1
```js
var removeNthFromEnd = function(head, n) {
  let dummy=new ListNode(0, head);
  let fast=dummy;slow=dummy;
  for(let i=0;i<=n;i++){//这里小于等于n
    fast=fast.next;
  }
  while(fast){
    fast=fast.next;
    slow=slow.next;
  }
  slow.next=slow.next.next;
  return dummy.next;
  };
```

## 面试题 02.07. 链表相交
[面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)
- 法一:前端对齐
```js
// 2. 前端对齐
// 考虑到重复的链表节点一定一样长，所以只需要从后往前保留一样长度即可
var getIntersectionNode = function(headA, headB) {
    // 先计算两个链表的长度分别是多少
    let la = 0
    let lb = 0
    let a = headA
    let b = headB
    while (a) {
      la ++
      a = a.next
    }
    while (b) {
      lb ++
      b = b.next
    }

    // 计算两个链表的长度差异，找出较长的链表
    let diff = Math.abs(la - lb)
    let large = null
    let small = null
    if (la > lb) {
      large = headA
      small = headB
    } else {
      large = headB
      small = headA
    }

    // 把较长的链表前端先剪切掉差异的数量，让两个链表长度一齐
    for (let i = 0;i < diff;i ++) {
      large = large.next
    }

    // 双指针一起遍历，找到第一个一样的即可
    while (large !== small) {
      large = large.next
      small = small.next
    }
    return large
};
```

## 142.环形链表Ⅱ
#快慢指针
### 快慢指针
[题解 angela:](https://leetcode.cn/problems/linked-list-cycle-ii/solutions/1083013/tu-jie-kuai-man-zhi-zhen-ji-qiao-yuan-li-5tz0/)
[题解:krahets](https://leetcode.cn/problems/linked-list-cycle-ii/solutions/12616/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/)
```js
var detectCycle = function(head) {
  // 快慢指针初始化指向 head
  let slow = head;
  let fast = head;
  // 快指针走到末尾时停止
  while (fast && fast.next) {
    // 慢指针走一步，快指针走两步
    slow = slow.next;
    fast = fast.next.next;
    // 快慢指针相遇，说明含有环
    if (slow == fast) {
      // 任一一节点指向头节点
      fast = head;
      // 同步向前进
      while (fast != slow) {
        fast = fast.next;
        slow = slow.next;
      }
      // 返回入口节点
      return fast;
    }
  }
  // 不包含环
  return null;   
};

作者：angela
链接：https://leetcode.cn/problems/linked-list-cycle-ii/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
### 哈希表
```js
var detectCycle = function(head) {
  let map=new Map();
  while(head){
    if(map.has(head)){
      return head
    }else{
      map.set(head,true);
      head=head.next;
    }
  }
  return null
};
```



## 876.链表的中间节点
[876.链表的中间节点](https://leetcode.cn/problems/middle-of-the-linked-list/description/)
- 思路
	求中间节点，除了暴力法，先求链表长度 length；一定要想到用双指针！
	用快指针 q 每次走2步；慢指针 p 每次走1步；
	这样走到终点，慢指针 p 就处于中间位置；
```js
var middleNode = function(head) {
 let n1=head;
 let n2=head;
 while(n2&&n2.next){
    n1=n1.next;
    n2=n2.next.next;
 }
 return n1
};
```
- 注意点
`while(n2)` 会出错, `TypeError: Cannot read properties of null (reading 'next')`.原因在于 `n2.Next` 可能是 null，null 不存在下一个节点
## 141.环形链表
[141.环形链表](https://leetcode.cn/problems/linked-list-cycle/solutions/261191/lei-si-xiao-xue-de-zhui-ji-wen-ti-kuai-man-zhi-zhe/)
### 快慢指针
```js
var hasCycle = function(head) {
    let n1=head;
    let n2=head;
    while(n2&&n2.next){
      n1=n1.next;
      n2=n2.next.next;
      if(n1==n2){
        return true;
      }
    }
  return false;
};
```
### 哈希表
```js
var hasCycle = function(head) {
let  map=new Map();
while(head){
  if(map.has(head)){
    return true
  }else{
    map.set(head,true);
    head=head.next;
  }
}
return false
};
```


## 回文链表
[回文链表](https://leetcode.cn/problems/palindrome-linked-list/solutions/457288/shou-hua-tu-jie-hui-wen-lian-biao-kuai-man-zhi-zhe/?envType=study-plan-v2&envId=top-100-liked)题解
```js
const isPalindrome = (head) => {
  if (head == null || head.next == null) {
    return true;
  }
  let fast = head;
  let slow = head;
  let prev;
  while (fast && fast.next) {
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }
  prev.next = null;  // 断成两个链表
  // 翻转后半段
  let head2 = null;
  while (slow) {
    const tmp = slow.next;
    slow.next = head2;
    head2 = slow;
    slow = tmp;
  }
  // 比对
  while (head && head2) {
    if (head.val != head2.val) {
      return false;
    }
    head = head.next;
    head2 = head2.next;
  }
  return true;
};
```
![|650](photo&pdf/Pasted%20image%2020231129152310.png)
![|650](photo&pdf/Pasted%20image%2020231129152326.png)

# 哈希表
**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**
## 有效的字母异位词

```js
/**
 * @description: 数组   TC:O(n)  SC:O(1)
 * @author: JunLiangWang
 * @param {*} s 给定字符串s
 * @param {*} t 给定字符串t
 * @return {*}
 */
/1.排序后比较字符串是否相等
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function (s, t) {
  if (s.length != t.length) return false;
  // 这里必须得用join去比较  不然比较的是引用对象  不管怎么样都不会相等的
  return [...s].sort().join("") == [...t].sort().join("");
};

/2.
function array(s, t) {
    /**
     * 本题使用数组的方式，由于字符串中仅
     * 存在小写字母，因此我们可以通过构建
     * 一个26位的数组，利用数组记录字符串
     * 中a-z的字符数量即可
     */
    // 如果两者长度不一致，肯定不为字母异位词
    if (s.length != t.length) return false
    // 定义一个26位的数组记录单词数量
    let wordList = new Array(26).fill(0)
    // 遍历字符串
    for (let i = 0; i < s.length; i++) {
        // 记录单词数量
        wordList[s.charCodeAt(i) - 97]++;
        wordList[t.charCodeAt(i) - 97]--;
    }
    // 遍历数组，如果某个单词数量不为0，则
    // 证明两字符串中该单词数量不一样
    for (let i = 0; i < 26; i++)if (wordList[i] != 0) return false
    return true
}



/**
 * @description: 哈希表  TC:O(n)  SC:O(n)
 * @author: JunLiangWang
 * @param {*} s 给定字符串s
 * @param {*} t 给定字符串t
 * @return {*}
 */
function hashMap(s, t) {
    /**
     * 本题使用哈希表的方式，与上述使用
     * 数组的方式思路一样，利用哈希表记
     * 录字符串中单词的数量
     */

    // 如果两者长度不一致，肯定不为字母异位词
    if (s.length != t.length) return false
    // 定义哈希表
    let map = new Map
    // 遍历字符串s，在hashMap中记录单词
    for (let i = 0; i < s.length; i++) {
        let count = map.get(s[i])
        map.set(s[i], count == undefined ? 1 : count + 1)
    }
    // 遍历字符串t
    for (let i = 0; i < t.length; i++) {
        let count = map.get(t[i])
        // 如果hashMap中单词数量为0，或没有
        // 这个单词，证明两字符单词数量不一致
        if (count == 0 || count == undefined) return false
        map.set(t[i], count - 1)
    }
    // 遍历hashMap，如果存在数量不为0的单词
    // 证明两字符单词数量不一致
    for (let key in map) if (map.get(key) != 0) return false

    return true
}
```

## 349. 两个数组的交集
[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)
[题解1](https://leetcode.cn/problems/intersection-of-two-arrays/solutions/1119239/349-liang-ge-shu-zu-de-jiao-ji-by-chen-w-p6dl/)
- 法1：集合 Set
```js
var intersection = function (nums1, nums2) {
    let set1 = new Set(nums1);
    let set2 = new Set(nums2);//数组转成set
    //if (set1.size > set2.size) {//用size小的数组遍历
    //    [set1, set2] = [set2, set1]
    //}
    const intersection = new Set();
    for (const num of set1) {//遍历set1
        if (set2.has(num)) {//元素如果不存在于set2中就加入intersection
            intersection.add(num);
        }
    }
    return [...intersection];//转成数组
};
```
没用必要进行数组的大小比较，因为 `set.Add()` 会自动去重,set 只保留不重复的值

> [!info] 找出较长/短的集合
```js
    if (set1.size > set2.size) {//用size小的数组遍历
        [set1, set2] = [set2, set1]
    }
    //set1永远是较短的那一个
```

## 快乐数
[快乐数](https://leetcode.cn/problems/happy-number/description/)
### 解题思路
有快乐数，形成不了循环。
没有快乐数，形成环路，造成死循环。

> [!example] 法一:哈希表 set /map
```js
/**
 * 解法1：哈希法
 * 缺点是用到哈希集合，空间复杂度过高
 */
const getSum = n => {
    let sum = 0
    while (n) {
        sum += (n % 10) ** 2
        n = Math.floor(n / 10)
    }
    return sum
}
var isHappy = function (n) {
    // Set写法
    let ret = new Set()
    while (1) {
        if (ret.has(n)) return false
        if (n === 1) return true
        ret.add(n)
        n = getSum(n)
    }
    // Map写法
    // let ret = new Map()
    // while (1) {
    //     if (ret.has(n)) return false
    //     if (n === 1) return true
    //     ret.set(n, 1)
    //     n = getSum(n)
    // }
};
```
> [!example] 法2:快慢指针 
```js 
/**
 * 解法2：快慢指针，与判断环形链大同小异
 * 比哈希解法好太多了，时间空间复杂度都很低
 */
const getSum = n => {
    let sum = 0
    while (n) {
        sum += (n % 10) ** 2
        n = Math.floor(n / 10)
    }
    return sum
}
var isHappy = function (n) {
    let slow = getSum(n), fast = getSum(getSum(n))
    while (slow !== fast) {
        slow = getSum(slow)
        fast = getSum(getSum(fast))
    }
    // 判断是否是因为1引起的循环，是的话就是快乐数，不是就代表非快乐数死循环
    return slow === 1
};
```

## 两数之和
[题目描述](https://leetcode.cn/problems/two-sum/description/)
[灵神题解](https://leetcode.cn/problems/two-sum/solutions/2326193/dong-hua-cong-liang-shu-zhi-he-zhong-wo-0yvmj/) 有一个动图对于理解很棒！
> [!example] 哈希表
> 本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value 结构来存放，key 来存元素，value 来存下标，那么使用 map 正合适。
```js
var twoSum = function (nums, target) {
    let idx = new Map(); // 创建一个空哈希表
    for (let j = 0; ; j++) { // 枚举 j
        const x = nums[j];
        // 在左边找 nums[i]，满足 nums[i]+x=target
        if (idx.has(target - x)) // 找到了
            return [idx.get(target - x), j]; // 返回两个数的下标
        idx.set(x, j); // 保存 nums[j] 和 j
    }
};

作者：灵茶山艾府
链接：https://leetcode.cn/problems/two-sum/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```


### 思路总结
> [!summary] 
>
很多涉及到「**两个变量**」的题目，都可以枚举其中一个变量，把它当成常量看待，从而转换成「一个变量」的问题。
代码实现时，通常来说「枚举右，寻找左」是更加好写的。
### 类似题(两个变量)
1. [1010. 总持续时间可被 60 整除的歌曲](https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/description/)
- 解题思路:
	`(a+b) % 60 === 0`，等价于 `(a%60 + b%60) % 60 === 0;`
	余数相加模60等于0,类似于两数相加
	`x=a%60,y=b%60`
	这里 `(x+y) % 60 = 0`，其中 `0<=x,y<60`，那么有两种情况：1. x+y=60; 2. x+y=0，这两种情况可以合并为：`y=(60-x) % 60`
- 代码:
```js
var numPairsDivisibleBy60 = function (time) {
  let map = new Map();
  let res = 0;
  for (i = 0; i < time.length; i++) {
    let x = time[i] % 60;
    let y = x==0? 0:60-x;
    if (map.has(y)) {
      res += map.get(y);
    }
    if (map.has(x)) {
      map.set(x, map.get(x) + 1);
    }
    if (!map.has(x)) {
      map.set(x, 1);
    }
  }
  return res;
};
```
y 当作移动指针，在左边寻找

## 四数相加Ⅱ
[四数相加Ⅱ](https://leetcode.cn/problems/4sum-ii/description/)
### 思路
主要是转化为两数之和

a+b 建一个表，key 为和，value 为次数。 c+d 遍历查表，看有没有等于 0- (c+d)的本题需要统计符合条件的元素组合数量，搞个 count 变量来记录查表结果即可
## 代码
```js
var fourSumCount = function (nums1, nums2, nums3, nums4) {
  let map = new Map();
  for (const a of nums1) {
    for (const b of nums2) {
      let sum = a + b;
      if (map.has(sum)) {
        map.set(sum, map.get(sum)+ 1);
      } else {
        map.set(sum, 1);
      }
    }
  }
  let result=0;
  for(const c of nums3){
    for(const d of nums4){
      let sum1=-(c+d);
      result+=map.has(sum1)? map.get(sum1):0
    }
  }
  return result
};
```

## 383.赎金信
题目: [赎金信](https://leetcode.cn/problems/ransom-note/description/)
```js
var canConstruct = function(ransomNote, magazine) {
    let arr1=[...ransomNote];
    let arr2=[...magazine];
    let map=new Map();
    for(const a of arr2){
        map.has(a)?map.set(a,map.get(a)+1):map.set(a,1);
    }
    for(const b of arr1){
        if(map.has(b)){
            map.set(b,map.get(b)-1);
            if(map.get(b)<0){
                return false;
            }
        }
        if(!map.has(b)) return false;
    }
    return true
};
```

## 三数之和
**题目**:
### 解题思路:
数组排序加双指针
### 代码:
```js
var threeSum = function (nums) {
  let len = nums.length;
  let result = [];
  nums.sort((a, b) => a - b);
  for (let i = 0; i < len - 2; i++) {
    let left = i + 1;
    let right = len - 1;
    if(i>0 && nums[i]==nums[i-1]) continue;//去重
    while (left<right) {
      let sum = nums[i] + nums[left] + nums[right];
      if (sum > 0 || nums[right]==nums[right+1]) right--;
      if (sum < 0 ) left++;
      if (sum == 0) {
        result.push([nums[i], nums[left], nums[right]]);
        left++;
        right--;
        //这里指针的去重一开始没考虑
        //去重逻辑应该放在找到一个三元组之后，对left和right去重
        while(nums[left]===nums[left-1]) left++;
        while(nums[right]===nums[right+1]) right++;
      }
    }
  }
  return result;
};
```

> [!NOTE] 注意点:去重
> 对于重复元素的跳过，首先是 i，其次是左右指针的去重。

## 四数之和

### 解题思路:

### 代码:
```js
var fourSum = function (nums, target) {
  let res = [];
  let len = nums.length;
  nums.sort((a, b) => a - b);
  for (let i = 0; i < len - 3; i++) {
    if (i > 0 && nums[i] == nums[i - 1]) continue;
    for (let j = i + 1; j < len - 2; j++) {
      if (j > i + 1 && nums[j] == nums[j - 1]) continue;
      let left = j + 1;
      let right = len - 1;
      while (left < right) {
        let sum = nums[i] + nums[j] + nums[left] + nums[right];
        if (sum == target) {
          res.push([nums[i], nums[j], nums[left], nums[right]]);
          left++;
          right--;
          while (nums[left] === nums[left - 1]) left++;
          while (nums[right] === nums[right + 1]) right--;
        } else if (sum < target) left++;
        else if (sum > target) right--;
      }
    }
  }
  return res;
};
```

# 字符串
## 反转字符串
[反转字符串](https://leetcode.cn/problems/reverse-string/)
### 解题思路
左右指针，两两交换位置，再向中间移动
### 代码
```js
var reverseString = function (s) {
  let left = 0;
  let right = s.length - 1;
  while (left < right) {
    [s[left], s[right]] = [s[right], s[left]];
    left++;
    right--;
  }
  return s;
};
//另外一种写法
var reverseString = function(s) {
    const n = s.length;
  	//双指针不断交换left和right位置的元素
    for (let left = 0, right = n - 1; left < right; left++, right--) {
        [s[left], s[right]] = [s[right], s[left]];
    }
};
作者：晨
链接：https://leetcode.cn/problems/reverse-string/

```
## 反转字符串Ⅱ
[反转字符串Ⅱ](https://leetcode.cn/problems/reverse-string-ii/)
### 题目思路
首先,要将==字符串转为数组==，一开始没考虑到
其次，取每个2k 长的字符中小于等于 k 长度的字符进行反转
 需要注意的是右指针可能会超过数组长度，需要进行判断
最后，将反转好的数组转为字符串
### 代码
```js
var reverseStr = function (s, k) {
  let arr = s.split("");
  const len = arr.length;
  for (let i = 0; i < len; i += 2 * k) {
    let left = i;
    let right = Math.min(left + k - 1, len - 1);
    while (left < right) {
      [arr[left], arr[right]] = [arr[right], arr[left]];
      left++;
      right--;
    }
  }
  return arr.join("");
};
```

## 替换数字
法1：Map 遍历+正则
```js

var __readline = require("readline-sync");
__readline.setDefaultOptions({ prompt: "" });
var readline = __readline.prompt;

let input = readline();

// 将字符串拆分为字符数组
const arr = input.split("");

// 使用 map 方法遍历数组并进行映射
const arr1 = arr.map((i) => {
  // 使用正则表达式检查是否是 1 到 9 之间的数字
  return /[1-9]/.test(i) ? "number" : i;
});

// 将数组拼接为字符串并输出
console.log(arr1.join(""));
```
法2：自己写的
```js
let input = readline();
arr = input.split("");
arr1 = [];
for (let i of arr) {
  if (i in [1, 2, 3, 4, 5, 6, 7, 8, 9]) {
    arr1.push("number");
  } else {
    arr1.push(i);
  }
}
arr1.join("");
console.log(arr1.join(""));
```
条件可以进行更换
```js
const readline=require("readline");
const rl=readline.createInterface({
    input:process.stdin,
    output:process.stdout
});
rl.on("line",(input)=>{
    let inputArr=input.split("");
    let newstr="";
    for (let i = 0; i < inputArr.length; i++) {
        if(inputArr[i]>="0" && inputArr[i]<="9"){
            newstr+="number"
        }else{
            newstr+=input[i]
        }
    }
    console.log(newstr);
    rl.close();
});
```
> [!NOTE] 遍历对象 or 数组
> 遍历对象的同时修改内容，可以使用 `arr.map((i)=>{表达式})`


> [!NOTE] 比较字符串
> 在 JavaScript 中，比较字符串时是逐字符比较它们的 Unicode 码点值。对于字符串 `"1" > "0"`，实际上是比较字符 `'1'` 和 `'0'` 的 Unicode 码点值。
Unicode 码点值是一种用于表示字符的数字标识。在 Unicode 中，数字字符的码点值是按顺序递增的，因此字符 `'1'` 的码点值大于字符 `'0'`，所以表达式 `"1" > "0"` 返回 `true`。
对于字符串 `"1" > "a"`，同样是逐字符比较 Unicode 码点值。在 Unicode 中，数字字符的码点值通常小于字母字符，因此字符 `'1'` 的码点值要小于字符 `'a'`，所以表达式 `"1" > "a"` 返回 `false`。

## 反转字符串中的单词
[反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/description/)
### 代码:
#### 法一 : 双指针
```js
var reverseWords = function (s) {
  // 1. 去除字符串首尾的空格
  let str = s.trim();
  const len = str.length;
  let i = 0;
  let j = 0;
  let res = [];

  // 2. 遍历字符串
  while (j < len) {
    // 3. 找到一个单词的末尾后的空格）
    while (str[j] !== " " && j < len) j++;
    // 4. 将找到的单词插入到结果数组的开头
    res.unshift(str.slice(i, j));
    // 5. 跳过空格，找到下一个单词的起始位置
    while (str[j] == " " && j < len) j++;
    // 6. 更新起始位置
    i = j;
  }
  // 7. 返回翻转后的单词数组，并转为字符串
  return res.join(“ ”);
};
```
需要考虑的是 j 到字符串末尾的时候，j=len-1; 但最后一个字符不是空，需要再加1，然后退出循环靠就 j<len 的条件，使得 j=len 停下。

> [!NOTE] 注意点
`str.slice(i,j)` 返回索引 i 到 j-1的子字符串

#### 法二 : 分割+倒序(split+push)

```js
var reverseWords = function (s) {
  wordArray = s.split(" ");
  const len = wordArray.length;
  let res = [];
  for (let i = len - 1; i >= 0; i--) {
    if (wordArray[i] == " ") continue;
    res.push(wordArray[i]);
  }
  return res.join(" ");
};
```
## 右旋字符串-卡码网
### 法一:普通双指针
```js
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
let inputArr = [];
rl.on('line', (input) => {
  inputArr.push(input);
  if (inputArr.length === 2) {
    let para = inputArr[0];
    let str = inputArr[1];
    let arrayStr = str.split('');
    let l = 0;
    let r = l + para;
    while (r < arrayStr.length) {
      l++;
      r++;
    }
    let arr1 = str.slice(l, r);
    let arr2 = str.slice(0, l);
    let newArrayStr = arr1 + arr2;
    console.log(newArrayStr);
    rl.close();
  }
});
```
### 多次反转


## strStr() 子字符串匹配
[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

### 代码
```js
var strStr = function(haystack, needle) {
    return haystack.indexOf(needle)
};
```

```js
var strStr = function(haystack, needle) {
    return haystack.search(needle)
};
```

```js
var strStr = function (haystack, needle) {
    if (needle === "") return 0
    for (var i = 0; i < haystack.length; i++) {
        if (haystack[i] === needle[0]) {
            if (haystack.substring(i, i + needle.length) === needle) return i;
        }
    }
    return -1
};

```
## 重复的子字符串
### 题目
给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。
[重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/description/)

### 代码
1. 法一:判断是否可以由字符串的重复构成
```js
const repeatedSubstringPattern = (s) => {
  // 1. 设置 s 的长度 length
  const length = s.length;

  // 2. 设置每次累加的长度
  let str = '';

  // 3. 遍历字符串
  for (let i = 0; i < s.length - 1; i++) {
    // 3.1 累加字符串
    substr += s[i];
    // 3.2 判断是否为重复的长度
    if (s === substr.repeat(Math.floor(length / str.length))) {
      return true;
    }
  }
  // 4. 如果不存在，则返回 false
  return false;
};
作者：小鸡炖蘑菇
```
- 主要用到了 substr.repeat(nums)的函数
- 注意点:不可遍历完整个字符串,遍历到最长的字符串 `i < s.length - 1

# 双指针法
## 移除元素
### 题目
给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
[27.移除元素](https://leetcode.cn/problems/remove-element/description/)
### 思路 &&代码
参考[笨猪爆破组](https://leetcode.cn/problems/remove-element/solutions/274185/javascript-si-chong-fang-fa-you-xian-zhang-wo-qian/)
#### 法一:左右指针顺序
- 遇到不同于 val 的项，就将它直接覆盖到 nums 数组中，从第一项开始覆盖
- 遍历完数组，不同于 val 的项都安排到了 nums 数组的前头
```js
var removeElement = function (nums, val) {
  let slow = 0;
  for (let fast = 0; fast < nums.length; fast++) {
    if (nums[fast] != val) {
      nums[slow] = nums[fast];
      slow++;
    }
  }
  return slow;
};
```

#### 法二:双指针首尾项
- 指向头尾的双指针
- 遇到等于 val 的项，就拿数组的末尾项覆盖它
- 末尾项搬到前面来了，将尾指针左移一位
- 如果遇到不同于 val 的项，左指针就+1，考察下一项
- 循环结束的条件是两个指针交叉相遇
```js
var removeElement = (nums, val) => {
  let index = 0, last = nums.length - 1
  while (index <= last) {
    if (nums[index] === val) {
      nums[index] = nums[last]
      last--
    } else {
      index++
    }
  }
  return index
}

```
## 反转字符串
### 题目
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
[344. 反转字符串](https://leetcode.cn/problems/reverse-string/description/)
### 思路&&代码
#### 直接 reverse
```js
var reverseString = function (s) {
    s.reverse();
};
```
#### 左右指针
```js
var reverseString = function (s) {
  let left = 0;
  let right = s.length - 1;
  while (left < right) {
    [s[left], s[right]] = [s[right], s[left]];
    left++;
    right--;
  }
  console.log(s);
};
```
# 栈与队列
[Javascript 中的栈和队列](https://juejin.cn/post/7098133664789168159)

## 常见操作
栈通常需要实现下面常用功能：
- push（插入新元素，并让新元素成为栈顶元素）
- pop（栈顶元素出栈，并返回栈顶元素）
- peek（想知道栈最后添加的是哪个，用这个方法。返回栈顶元素，不出栈。是个辅助方法）
- clear（清空栈）
- isEmpty（若栈为空，返回 true，否则返回 false）
- size（返回栈元素个数）

## 用栈实现队列

### 思路
两个栈可实现将列表倒序：设有含三个元素的栈 `A = [1,2,3`] 和空栈 `B = []` 。若循环执行 A 元素出栈并添加入栈 B ，直到栈 A 为空，则 `A = []` , `B = [3,2,1]` ，即栈 B 元素为栈 A 元素倒序。
### 函数设计
1. 加入队尾 push() ： 将数字 x 加入栈 A 即可。
2. 获取队首元素 peek() ：
	如果 B 为空,且 A 为空,即两个栈都为空，无元素，因此返回 -1 。
	如果 B 为空,A 不为空： 将栈 A 元素全部转移至栈 B 中，实现元素倒序.
	最后,此时 B 不为空时,返回栈 B 的栈顶元素。
弹出队首元素 pop() ：
	如果 B 为空,且 A 为空,即两个栈都为空，无元素，因此返回 -1 。
	如果 B 为空,A 不为空： 将栈 A 元素全部转移至栈 B 中，实现元素倒序.
	最后,弹出 B 的栈顶元素。
3. 队列判空 empty() ： 当栈 A 和 B 都为空时，队列为空。
### 代码
```js
var MyQueue = function () {
  this.A = [];
  this.B = [];
};
/**
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function (x) {
  this.A.push(x);
};
/**
 * @return {number}
 */
MyQueue.prototype.pop = function () {
  if (!this.B.length) {
    while (this.A.length) {
      this.B.push(this.A.pop());
    }
  }
  return this.B.pop();
};
/**
 * @return {number}
 */
MyQueue.prototype.peek = function () {
  if (!this.B.length) {
    while (this.A.length) {
      this.B.push(this.A.pop());
    }
  }
  return this.B[this.B.length - 1];
};
/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function () {
  return !this.A.length && !this.B.length
};

```

## 队列实现栈
## 有效的括号
[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/description/)
### 算法思路&流程:
- 思路一
1. 如果 val 是左括号,则入栈.
2. 如果 val 不是左括号,通过哈希表或者多个 if 判断括号对应关系,若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 val 不对应，则提前返回 false。
```js
var isValid = function(s) {
    let stack=[]
    for(let val of s ){
	    // if([")", "}", "]"].includes(val))
        if(val=== "(" || val=== "[" || val==="{"){
            stack.push(val)
        }else{
            if(stack.length===0)return false
            if(val===")"&&stack.pop()!=="(")return false
            if(val==="]"&&stack.pop()!=="[")return false
            if(val==="}"&&stack.pop()!=="{")return false
        }
    }
    return !stack.length
};
```
- 思路二
1. 如果 val 是左括号,则入栈对应的右括号.
2. 如果 val 不是左括号,~~通过哈希表或者多个 if 判断括号对应关系~~,只需要判断 stack.pop() 与当前遍历括号 val 对不对应,不对应直接返回 false.

```js
var isValid = function(s) {
    const stack = [];
    for (let val of s) {
        console.log(stack)
        if (val === '(') stack.push(')');
        else if (val === '[') stack.push(']');
        else if (val === '{') stack.push('}');
        else if (stack.length === 0 || val !== stack.pop()) return false;
    }
    return stack.length === 0;
};
```
## 删除字符串中所有相邻重复项
### 思路
	字符串转数组
	遍历字符串
		栈为空,输入栈,下个循环
		栈不为空,栈顶内容跟当前项比较
			 相等,pop(当前项)
			 不相等,push(当前项)
### 函数设计
### 代码
```js
var removeDuplicates = function (s) {
  let arr = s.split('');
  let stack = [];
  let i = 0;
  while (i < arr.length) {
    if (stack.length == 0) {
      stack.push(arr[i]);
      i++;
    } else {
      let cur = stack.pop();
      if (arr[i] == cur) {
        i++;
        continue;
      } else {
        stack.push(cur);
        stack.push(arr[i]);
        i++;
      }
    }
  }
  return stack;
};
```

```js
var removeDuplicates = function(S) {
    let stock = [];
    for(let item of S){
        if(stock[stock.length - 1] === item){
            stock.pop();
        }else{
            stock.push(item);
        }
    }
    return stock.join("");
};
```

##  逆波兰表达式求值
### 题目描述
![|500](photo&pdf/Pasted%20image%2020231218224903.png)
### 思路:
自己想的
	新创 stack
	循环遍历tokens
		没遇到运算符,字符数组stack.push
		一旦遇到运算符,两次 pop,第一次 pop 放运算符的右边,第二次 pop 放运算符的左边
		存取运算结果,push
### 代码
```python
var evalRPN = function (tokens) {
  let stack = [];
  let opreators = ['+', '-', '*', '/'];
  let res = tokens[0];

  for (let s of tokens) {
    if (opreators.includes(s)) {
      let right = stack.pop();
      let left = stack.pop();
      switch (s) {
        case '+':
          res = left + right;
          break;
        case '-':
          res = left - right;
          break;
        case '*':
          res = left * right;
          break;
        case '/':
          res = parseInt(left/right);
          break;
      }
      stack.push(res);
    } else {
      s = +s;
      stack.push(s);
    }
  }
  return res;
};
```

> [!NOTE] swtich 语法
> 每个 case 后要加`break`


### 坑1:字符串转数字
1. parseInt
2. parseFloat(string)
3. Number(object)
4. 一元运算符(+)
```python
+"023" //23 推荐使用 + 
+"16"  //16
+"-15" //-15
+"-0xFF" //NaN  
+"0xFF"  //255
```
### 坑2:除法取整问题
题目中的要求应该是向0取整,采用 math.floor 时,除法结果为负数时,会不通过
- 向0取整,只取整数位
	1. parseInt(num)
	2. 位运算 (num|0)
		```python
		console.log(0.8 | 0);//输出0
		console.log(-0.8 | 0);//输出0
		console.log(1 | 0);//输出1
		```
-  向下取整
	1. Math.floor()
## 滑动窗口最大值
### 题目:
[239. 滑动窗口最大值]( https://leetcode.cn/problems/sliding-window-maximum/description/ )
![|500](photo&pdf/Pasted%20image%2020231219125327.png)
### 思路:
- 暴力法
1. 左右指针代表区间
2. 区间内求最大值
	排序区间长度的最后一个
- #单调队列
	1. 初始答案数组为空
	2. 遍历数组,设定滑动窗口右边
	3. 保证队列数组是单调减的,如果一直遇到下一个数字比队列中的值大,那么删去队列的值
	4. 放入这个值
	5. 查看左边界,根据左边界的值查看是否成为窗口
	6. 形成窗口时,队列第一个值 push 进结果数组
	7. 判断当前窗口的左边界值是否等于队首元素,相等则需要 deque.shift()  
```js
var maxSlidingWindow = function (nums, k) {
  if (nums.length == 0 || k == 0) return [];
  let deque = [];
  let res = [];
  for (let right = 0; right < nums.length; right++) {
    while (deque.length && nums[right] > deque[deque.length - 1]) {//保证局部老大前面是没有值的,后面可以跟着小弟,因为小弟有可能成为下一个老大
      deque.pop();
    }
    deque.push(nums[right]);
    let left = right - k + 1;
    if (left >= 0 && left <= nums.length - k) {//判断窗口是否形成
      res.push(deque[0]);
      if (deque[0] == nums[left]) {//即将进入下个窗口,当前窗口左边界是队首元素,换句话说当前队首元素已经做不成老大了,需要换老大了
        deque.shift();
      }
    }
  }
  return res;
};
```

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function (nums, k) {
  if (nums.length == 0 || k == 0) return [];
  let deque = [];
  let res = new Array(nums.length - k + 1);
  // 未形成窗口
  for (let i = 0; i < k; i++) {
    // deque保持单调递增  （把前面体重不足的都压扁了，直到遇到更大的量级才停住）
    while (deque.length && deque[deque.length - 1] < nums[i]) deque.pop();
    deque.push(nums[i]);
  }
  res[0] = deque[0];
  // 形成窗口后
  for (let i = k; i < nums.length; i++) {
    // nums[i - k] 是窗口的左边界 是当前轮要被移出去的  如果这个元素在单调队列中，则直接删除
    if (deque[0] == nums[i - k]) deque.shift();
    // deque保持单调递增  （把前面体重不足的都压扁了，直到遇到更大的量级才停住）
    while (deque.length && deque[deque.length - 1] < nums[i]) deque.pop();
    // 加入窗口右边界的值
    deque.push(nums[i]);
    // 当前窗口的最大值
    res[i - k + 1] = deque[0];
  }
  return res;
};
```
关键点:
1.  // `nums[i - k]` 是窗口的左边界是当前轮要被移出去的如果这个元素在单调队列中，则直接删除
2. 把前面体重不足的都压扁了，直到遇到更大的量级才停住
## 前 k 个高频元素
### 题目
[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)
![](photo&pdf/Pasted%20image%2020231220144000.png)
### 思路
利用 map 统计每个元素出现次数
按次数降序排列，取前 k 个元素
### 代码
```js
var topKFrequent = function(nums, k) {
    let map = new Map();
    let res = [];
    for(let i = 0; i < nums.length; i++) {
        if(map.has(nums[i])) {
            map.set(nums[i], map.get(nums[i]) + 1);
        } else {
            map.set(nums[i], 1);
        }
    }
    //返回一个按出现次数降序的二维数组
    let sortArray = Array.from(map).sort((a, b) => b[1] - a[1]);
    for(let i = 0; i < k; i++) {
        res.push(sortArray[i][0]);
    }
    return res;
};
```
### map 按照 value 值排序

```javascript
const myMap = new Map([
  ['key1', 30],
  ['key2', 10],
  ['key3', 20]
]);

// 将 Map 转换为包含键值对的数组
const mapEntriesArray = Array.from(myMap.entries());
//输出:[ [ 'key2', 10 ], [ 'key3', 20 ], [ 'key1', 30 ] ]

// 根据值进行排序
mapEntriesArray.sort((a, b) => a[1] - b[1]);

// 将排序后的数组转换回 Map
const sortedMap = new Map(mapEntriesArray);
console.log(sortedMap);
// 输出: Map { 'key2' => 10, 'key3' => 20, 'key1' => 30 }
```

在这个例子中，`Array.from(myMap.entries())` 将 `myMap` 中的键值对转换为数组，然后通过 `sort` 方法根据值进行排序。最后，使用排序后的数组创建一个新的 `Map` 对象。

请注意，这种方法会创建一个新的 `Map`，而不会修改原始的 `Map`。如果需要在原始 `Map` 上进行排序，可以将排序的逻辑集成到你的应用程序中。


# 回溯
## 典型问题
回溯法，一般可以解决如下几种问题：
- (全排列)组合问题：N 个数里面按一定规则找出 k 个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个 N 个数的集合里有多少符合条件的子集
- 排列问题：N 个数按一定规则全排列，有几种排列方式
- 棋盘问题：N 皇后，解数独等等
## 回溯模板
![](photo&pdf/Pasted%20image%2020231221222937.png)
```python
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 77.组合
### 题目
[77.组合](https://leetcode.cn/problems/combinations/)
给定两个整数 n 和 k，返回范围 `[1, n]` 中所有可能的 k 个数的组合。
你可以按任何顺序返回答案。
### 思路
### 代码
```js
const combine = (n, k) => {
  const res = [];

  const helper = (start, path) => { // start是枚举选择的起点 path是当前构建的路径（组合）
    if (path.length == k) {
      res.push(path.slice());       // 拷贝一份path，推入res
      return;                       // 结束当前递归
    }
    for (let i = start; i <= n; i++) { // 枚举出所有选择
      path.push(i);                    // 选择
      helper(i + 1, path);             // 向下继续选择
      path.pop();                      // 撤销选择
    }
  };

  helper(1, []); // 递归的入口，从数字1开始选
  return res;
}
```

> [!NOTE] 注意点
>1. path 的拷贝  `path.slice()`
>2. 剪枝操作
>

## 组合总和 III
[216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/description/)
### 题目描述:
找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：
	只使用数字1到9
	每个数字最多使用一次 
	返回所有可能的有效组合的列表。该列表不能包含相同的组合两次，组合可以以任何顺序返回。
### 思路:
如果 path 中的数相加等于9 且长度等于k
```js
var combinationSum3 = function (k, n) {
  const res = [];
  const helper = (start, path) => {
    let res1 = path.reduce((sum, cur) => sum + cur, 0); //求和
    if (res1 === n && path.length === k) {
      res.push(path.slice()); // 拷贝一份path，推入res
      return;
    }
    if (res1 > n || path.length > k) return; //剪枝
    for (let i = start; i <= Math.min(n - k + 1, 9); i++) {
      // 枚举出所有选择
      path.push(i); // 选择
      helper(i + 1, path); // 向下继续选择
      path.pop(); // 撤销选择
    }
  };
  helper(1, []); // 递归的入口，从数字1开始选
  return res;
};
console.log(combinationSum3(9, 45));
```
### 剪枝操作
1. 已选元素总和如果已经大于 n（图中数值为4）了，那么往后遍历就没有意义了，直接剪掉。
2. 对于小于9的的数使用 n-k+1,最大的能到的数是 n-k,但需要加1
	对于7来说,取长度为3, `1,2,4` 4就是最大能到达的数,但由于循环遍历的时候,需要加1,把结果存入进去.

## 不同集合之间的组合
### 题目描述
[17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)
![](photo&pdf/Pasted%20image%2020231223125929.png)
### 思路
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2023%2F12%2F31%2F20231231162339_16-23-40.png)
### 代码
1. 不需要pop
```js
const letterCombinations = (digits) => {
  if (digits.length == 0) return [];
  const res = [];
  const map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' };
  // dfs: 当前构建的字符串为curStr，现在“翻译”到第i个数字，基于此继续“翻译”
  const dfs = (curStr, i) => {   // curStr是当前字符串，i是扫描的指针
    if (i > digits.length - 1) { // 指针越界，递归的出口
      res.push(curStr);          // 将解推入res
      return;                    // 结束当前递归分支
    }
    const letters = map[digits[i]]; // 当前数字对应的字母
    for (const letter of letters) { // 一个字母是一个选择，对应一个递归分支
      dfs(curStr + letter, i + 1);  // 选择翻译成letter，生成新字符串，i指针右移继续翻译（递归）
    }
  };
  dfs('', 0); // 递归的入口，初始字符串为''，从下标0开始翻译
  return res;
};

```
在这段代码中，由于采用了深度优先搜索 (DFS) 的递归方式，每次递归调用都传递了新的 `curStr`，而不是修改原有的 `curStr`。在递归结束后，当前层的状态并不会对下一层产生影响。因此，不需要在递归回溯时手动执行 `pop` 操作。

在每一次递归调用时，都将新的字符拼接到 `curStr` 中，而在递归结束后，当前层的 `curStr` 变量仍然是原始状态，不受递归调用的影响。这样就避免了手动执行 `pop` 操作，而是通过不同的 `curStr` 传递状态，使得递归调用之间相互独立，不产生副作用。

2. 需要 pop
- temp.pop()
在深度优先搜索 (DFS) 过程中，`temp` 数组用于存储当前组合的字符，而且在递归的过程中，我们会不断地往 `temp` 中添加字符。当递归回溯到上一层时，为了保持当前状态，需要将最后添加的字符从 `temp` 中移除，以便接下来的搜索可以选择不同的字符。这是为了确保每一层递归结束后，`temp` 数组都是初始状态，以便下一次搜索。因此，`temp.pop()` 的作用是在深度优先搜索回溯时，将最后添加的字符弹出，恢复到上一层的状态。

```js
let letterCombinations2 = function (digits) {
	if(digits.length===0) return [];
  const map = {
    2: 'abc',
    3: 'def',
    4: 'ghi',
    5: 'jkl',
    6: 'mno',
    7: 'pqrs',
    8: 'tuv',
    9: 'wxyz',
  };
  let res = [];
  const helper = (curStr, i) => {
    if (curStr.length >= digits.length) {
      res.push(curStr.slice()); // 使用slice进行拷贝，保留当前状态
      return;
    }
    let letters = map[digits[i]];
    for (const letter of letters) {
      curStr += letter; // 拼接字符到当前状态
      helper(curStr, i + 1);
      curStr = curStr.slice(0, -1); // 执行pop操作，恢复当前状态
    }
  };
  helper('', 0);
  return res;
};
```

## 组合总和
### 题目链接
[39.组合总和](https://leetcode.cn/problems/combination-sum/description/)
给你一个无重复元素的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的所有不同组合，并以列表形式返回。你可以按任意顺序返回这些组合。

candidates 中的同一个数字可以无限制重复被选取。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

### 思路
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2023%2F12%2F31%2F20231231185948_18-59-49.png)
**去重**:选择第一个数即第一层时,当选择 `candidates[i]` 时, `candidates[0,i-1`]应该剪枝.

### 代码
```js
let combinationSum = function (candidates, target) {
  // 先排序，方便后续去重和剪枝
  candidates.sort((a, b) => a - b);

  // 如果最小的候选数都大于目标值，直接返回空数组
  if (candidates[0] > target) return [];
  let res = [];
  // 深度优先搜索函数
  const dfs = (path, start) => {
    // 计算当前路径的和
    let sum = path.reduce((sum, cur) => sum + cur, 0);
    // 如果当前路径的和等于目标值，将路径加入结果数组
    if (sum === target) {
      res.push(path.slice());
      return;
    }
    // 如果当前路径的和大于目标值，直接返回，进行剪枝
    if (sum > target) return;
    // 遍历候选数,从start开始,去重
    for (let i = start; i < candidates.length; i++) {
      // 做选择
      path.push(candidates[i]);
      // 递归调用，注意这里传递的下一个起始位置仍然是 i，允许重复选择同一个数
      dfs(path, i);
      // 撤销选择，为下一轮的选择做准备
      path.pop();
    }
  };

  // 从第一个候选数开始深度优先搜索
  dfs([], 0);
  return res;
};
```

## 组合总和Ⅱ
### 题目链接
[40.组合总和Ⅱ](https://leetcode.cn/problems/combination-sum-ii/)
给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

**区别**与 [组合总和](#组合总和):candidates 中的每个数字在每个组合中只能使用一次。

注意：解集不能包含重复的组合。
### 思路&& 代码
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2023%2F12%2F31%2F20231231201839_20-18-40.png)


```js
let combinationSum2 = function (candidates, target) {
  let res = [];
  candidates.sort((a, b) => a - b);
  let dps = (path, start) => {
    let sum = path.reduce((sum, cur) => sum + cur, 0);
    if (sum >= target) {
      if (sum === target) {
        res.push(path.slice());
      }
      return;
    }
    for (let i = start; i < candidates.length; i++) {
      if (i - 1 >= start && candidates[i - 1] == candidates[i]) {
        continue;
      }

      path.push(candidates[i]);
      dps(path, i + 1);
      path.pop();
    }
  };
  dps([], 0);
  return res;
};
```
#### 注意点 :
 1. 给定的数组可能有重复的元素，先排序，使得重复的数字相邻，方便去重。
 2. for 枚举出选项时，加入下面判断，从而忽略掉同一层重复的选项，避免产生重复的组合。比如 `[1,2,2,2,5`]，选了第一个 2，变成 `[1,2]`，它的下一选项也是 2，跳过它，因为如果选它，就还是 `[1,2]`。
	```js
	if (i - 1 >= start && candidates[i - 1] == candidates[i]) {
    continue;
}
	```
> [!warning] 对于每一层来说,同一层忽略重复的.即第二次出现的.因此需要加上 `i-1>=start` 的条件

3. 当前选择的数字不能和下一个选择的数字重复，给子递归传 i+1，避免与当前选的 i 重复。
	```js
	dps(path, i + 1);
	```
## 分割回文串
### 题目
给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。
回文串是正着读和反着读都一样的字符串。
[131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/description/)
### 思路
[笨猪爆破组的题解](https://leetcode.cn/problems/palindrome-partitioning/solutions/639915/shou-hua-tu-jie-san-chong-jie-fa-hui-su-q5zjt/)
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F01%2F20240101153749_15-37-50.png)

### 代码
```jsx
// 主函数，接收一个字符串s作为输入
var partition = function (s) {
  // res用于存储所有的分割方式
  let res = [];

  // 定义深度优先搜索函数，path记录当前路径，start表示当前的开始位置
  dfs = (path, start) => {
    // 如果开始位置已经到达字符串的末尾，那么将当前路径添加到结果中
    if (start === s.length) {
      res.push(path.slice());
      return;
    }
    // 从开始位置开始，尝试所有可能的结束位置
    for (let i = start; i < s.length; i++) {
      // 如果从开始位置到当前位置的子串是一个回文串，那么将其添加到路径中，并继续搜索
      if (isPali(s, start, i)) {
        path.push(s.substring(start, i + 1));
        dfs(path, i + 1);
        // 回溯，将当前添加的子串从路径中移除
        path.pop();
      }
    }
  };
  // 从位置0开始搜索
  dfs([], 0);
  // 返回所有的分割方式
  return res;
};

// 辅助函数，用于判断一个字符串是否是回文串
const isPali = (s, l, r) => {
  // 从两端开始，向中间检查
  while (l <= r) {
    // 如果两端的字符不相等，那么这个字符串不是回文串
    if (s[l] !== s[r]) {
      return false;
    }
    // 向中间移动
    l++;
    r--;
  }
  // 如果所有的字符都检查过，那么这个字符串是回文串
  return true;
};
```
### 区别
个人感觉区别于组合问题的有两点的不同,一个是 res.path 时的条件,一个是 path.push 时的区别.还得加上额外的条件:子字符串回文的判断.
关键得画好图,然后背模板

## 复原 IP 地址(难)
### 注意点
1. path.join(".")的返回值
2.start + len 满足条件时应该等于s.length
## 思路 && 代码
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F01%2F20240101185033_18-50-34.png)
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F01%2F20240101185040_18-50-40.png)


```js
const restoreIpAddresses = (s) => {
  const res = [];
  // 复原从start开始的子串
  const dfs = (subRes, start) => {
    if (subRes.length == 4 && start == s.length) {
      // 片段满4段，且耗尽所有字符
      res.push(subRes.join('.')); // 拼成字符串，加入解集
      return; // 返不返回都行，指针已经到头了，严谨的说还是返回
    }
    if (subRes.length == 4 && start < s.length) {
      // 满4段，字符未耗尽，不用往下选了
      return;
    }
    for (let len = 1; len <= 3; len++) {
      // 枚举出选择，三种切割长度
      if (start + len > s.length) return; // 加上要切的长度就越界，不能切这个长度
      if (len != 1 && s[start] == '0') return; // 不能切出'0x'、'0xx'

      const str = s.substring(start, start + len); // 当前选择切出的片段
      if (len == 3 && +str > 255) return; // 不能超过255

      subRes.push(str); // 作出选择，将片段加入subRes
      dfs(subRes, start + len); // 基于当前选择，继续选择，注意更新指针
      subRes.pop(); // 上面一句的递归分支结束，撤销最后的选择，进入下一轮迭代，考察下一个切割长度
    }
  };

  dfs([], 0); // dfs入口
  return res;
};
```
来源于[笨猪爆破组](https://leetcode.cn/problems/restore-ip-addresses/solutions/366627/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/)

## 子集问题
### 题目
给你一个整数数组 nums ，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。
解集不能包含重复的子集。你可以按任意顺序返回解集。
[78. 子集](https://leetcode.cn/problems/subsets/description/)
### 思路 && 代码
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F02%2F20240102202243_20-22-43.png)

```js
// 主函数，接收一个数组nums作为输入
var subsets = function (nums) {
  // res用于存储所有的子集
  let res = [];

  // 定义深度优先搜索函数，path记录当前路径，start表示当前的开始位置
  const helper = (path, start) => {
    // 如果开始位置没有超过数组的长度，那么将当前路径添加到结果中
    if (start <= nums.length) {
      res.push(path.slice());
      // 如果开始位置已经到达数组的末尾，那么返回
      if (start === nums.length) {
        return;
      }
    }
    
    res.push(path.slice()) //这里只需要一行,因为start最大为nums.length
    
    // 从开始位置开始，尝试所有可能的下一个位置
    for (let i = start; i < nums.length; i++) {
      // 将当前位置的元素添加到路径中，并继续搜索
      path.push(nums[i]);
      helper(path, i + 1);
      // 回溯，将当前添加的元素从路径中移除
      path.pop();
    }
  };
  // 从位置0开始搜索
  helper([], 0);
  // 返回所有的子集
  return res;
};
```
### 子集问题和排列问题的区别
子集问题是无序的，取过的元素不会重复取，写回溯算法的时候，for 就要从 startIndex 开始，而不是从0开始！

有同学问了，什么时候 for 可以从0开始呢？

求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续的文章就会讲到的。

## 子集Ⅱ
### 题目
[90.子集Ⅱ](https://leetcode.cn/problems/subsets-ii/description/)
给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集不能包含重复的子集。返回的解集中，子集可以按任意顺序排列。
### 思路 && 代码
这段代码是一个用于生成包含重复元素的子集的函数。让我们逐步解释它的工作原理：
1. 首先，定义了一个名为 `subsetsWithDup` 的函数，它接受一个参数 `nums`，表示输入的数组。
2. 在函数内部，创建了一个空数组 `res`，用于存储生成的子集。
3. 接下来，对输入数组 `nums` 进行排序，以确保相同的元素相邻。
4. 定义了一个名为 `helper` 的辅助函数，它接受两个参数：`path` 表示当前生成的子集，`start` 表示当前处理的元素索引。
5. 在 `helper` 函数内部，首先判断 `start` 是否小于等于 `nums` 数组的长度。如果是，将当前的 `path` 数组拷贝并添加到结果数组 `res` 中。这样可以确保每次生成的子集都是不同的。
6. 如果 `start` 等于 `nums` 数组的长度，说明已经处理完所有元素，直接返回。
7. 接下来，使用一个循环从 `start` 开始遍历 `nums` 数组的元素。
8. 在循环中，首先判断当前元素是否与前一个元素相同，如果是，则跳过当前循环，以避免生成重复的子集。
9. 如果当前元素不同于前一个元素，将当前元素添加到 `path` 数组中。
10. 然后，递归调用 `helper` 函数，将 `path` 和 `i + 1` 作为参数传递进去，以处理下一个元素。
11. 递归调用结束后，将 `path` 数组的最后一个元素移除，以便处理下一个元素的情况。
12. 最后，在函数的最外层调用 `helper` 函数，初始时将空数组 `[]` 和索引 `0` 作为参数传递进去，开始生成子集。
13. 最后，返回存储所有子集的结果数组 `res`。
```js
var subsetsWithDup = function (nums) {
  let res = [];
  nums.sort((a, b) => a - b);
  const helper = (path, start) => {
    if (start <= nums.length) {
      res.push(path.slice());
      if (start == nums.length) {
        return;
      }
    }
    for (let i = start; i < nums.length; i++) {
      if (i > start && nums[i] == nums[i - 1]) {
        continue;
      }
      path.push(nums[i]);
      helper(path, i + 1);
      path.pop();
    }
  };
  helper([], 0);
  return res;
};
```

##  非递减子序列
### 题目
[491. 非递减子序列](https://leetcode.cn/problems/non-decreasing-subsequences/description/)

### 思路 && 代码
```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var findSubsequences = function (nums) {
  let res = [];
  const set = new Set();
  const helper = (path, start) => {
    if (start <= nums.length) {
      if (path.length >= 2) {
        const str = path.toString();
        if (!set.has(str)) {
          set.add(str);
          res.push(path.slice());
        }
      }
      if (start == nums.length) {
        return;
      }
    }
    for (let i = start; i < nums.length; i++) {
      //if (i > start && nums[i] <= nums[i - 1]) {
        //continue;
     // }
      if (nums[i] <path[path.length - 1]) {
        continue;
      }
      path.push(nums[i]);
      helper(path, i + 1);
      path.pop();
    }
  };
  helper([], 0);
  return res;
};
```
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F04%2F20240104205355_20-53-56.png)
使用 set 来去重,而不是 `if (i > start && nums[i] <= nums[i - 1])`.因为数组是无序的,看上面的例子就能明白.
```js
      if (i > start && nums[i] <= nums[i - 1]) {
        continue;
      }
```

## 全排列
### 题目
给定一个不含重复数字的数组 nums ，返回其所有可能的全排列。你可以按任意顺序返回答案。
[46.全排列](https://leetcode.cn/problems/permutations/description/)
### 思路 &&代码
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F05%2F20240105080042_08-00-43.png)
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F05%2F20240105080051_08-00-52.png)

```js
const permute = (nums) => {
    const res = [];
    const used = {};

    function dfs(path) {
        if (path.length == nums.length) { // 个数选够了
            res.push(path.slice()); // 拷贝一份path，加入解集res
            return;                 // 结束当前递归分支
        }
        for (const num of nums) { // for枚举出每个可选的选项
            // if (path.includes(num)) continue; // 别这么写！查找是O(n)，增加时间复杂度
            if (used[num]) continue; // 使用过的，跳过
            path.push(num);         // 选择当前的数，加入path
            used[num] = true;       // 记录一下 使用了
            dfs(path);              // 基于选了当前的数，递归
            path.pop();             // 上一句的递归结束，回溯，将最后选的数pop出来
            used[num] = false;      // 撤销这个记录
        }
    }

    dfs([]); // 递归的入口，空path传进去
    return res;
};
```
作者：笨猪爆破组
链接： https://leetcode.cn/problems/permutations/solutions/247052/chou-xiang-cheng-jue-ce-shu-yi-ge-pai-lie-jiu-xian/
### 定义长度为 n 的空数组

## 带有重复数字的全排列问题
### 题目
给定一个可包含重复数字的序列 nums ，按任意顺序返回所有不重复的全排列。
[47.全排列Ⅱ](https://leetcode.cn/problems/permutations-ii/description/)
## 思路 && 代码
```js
const permuteUnique = (nums) => {
    const res = [];
    const used = new Array(nums.length);
    nums.sort((a, b) => a - b); // 升序排序

    const helper = (path) => {
        if (path.length == nums.length) { // 个数选够了
            res.push(path.slice());       // path的拷贝 加入解集
            return;                       // 结束当前递归分支
        }

        for (let i = 0; i < nums.length; i++) { // 枚举出所有的选择
            if (used[i]) {                      // 这个数使用过了，跳过。
                continue;
            }
            if (i - 1 >= 0 && nums[i - 1] == nums[i] && !used[i - 1]) { // 避免产生重复的排列
                continue;
            }
            path.push(nums[i]); // make a choice
            used[i] = true;     // 记录路径上做过的选择
            helper(path);       // explore，基于它继续选，递归
            path.pop();         // undo the choice
            used[i] = false;    // 也要撤销一下对它的记录
        }
    };

    helper([]);
    return res;
};
```
作者：笨猪爆破组
链接： https://leetcode.cn/problems/permutations-ii/solutions/418052/shou-hua-tu-jie-li-yong-yue-shu-tiao-jian-chong-fe/

### 难点:剪枝
1. 一个数字不能重复地被选。
使用 used 来标记
2. 不能产生重复的排列。重复的排列是怎么产生的？
对应上面第二点，如果当前的选项 `nums[i]`，与同一层的前一个选项 `nums[i-1]`相同，且 `nums[i-1]`存在，**且没有被使用过**，则忽略选项 `nums[i]`。
**如果 `nums[i-1]`被使用过**，它会被第一条修剪掉，不是选项了，即便它和 `nums[i]`重复，`nums[i]`还是可以选的。
# 贪心
## 分发饼干
### 题目
[455.分发饼干](https://leetcode.cn/problems/assign-cookies/description/)
### 思路 && 代码
1. 一种最简单的方式就是先从胃口最小的孩子开始，拿最小的饼干试一下能不能满足他，如果能满足就更好，如果不能满足，在找稍微大一点的，如果还不能满足就再找更大一点的……

```js
var findContentChildren = function(g, s) {
  // 对孩子们的胃口值进行排序
  g.sort((a, b) => a - b);
  // 对饼干的尺寸进行排序
  s.sort((a, b) => a - b);
  
  let res = 0; // 记录可以满足的孩子数量
  for (let i = 0; i < s.length; i++) { // 遍历每一块饼干
      // 如果当前的饼干可以满足当前的孩子
      if (res < g.length && g[res] <= s[i]) {
          res += 1; // 增加满足的孩子数量
      }
  }
  return res; // 返回最大的满足孩子数量
};
```
## 摆动序列
### 题目
[376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/description/)
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
### 思路
主要需要考虑三种情况
- 情况一：数组首尾两端 
	结果先置为1,出现摆动的话加1,所以最少为2个数
- 情况二：上下坡中有平坡(下图)
- 情况三：单调坡中有平坡(下图)

![上下坡中有平坡|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F08%2F20240108141520_14-15-21.png)
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F08%2F20240108141503_14-15-04.png)

### 代码
```js
var wiggleMaxLength = function (nums) {
  // 初始化摆动序列的长度为1
  let count = 1;

  // 初始化前一个差值为0
  let prevDiff = 0;

  // 从数组的第二个元素开始遍历
  for (let i = 1; i < nums.length; i++) {
    // 计算当前元素和前一个元素的差值
    let diff = nums[i] - nums[i - 1];

    // 如果当前差值大于0且前一个差值小于等于0，或者当前差值小于0且前一个差值大于等于0
    // 这意味着当前元素和前一个元素形成了一个摆动，所以摆动序列的长度加1
    if ((diff > 0 && prevDiff <= 0) || (diff < 0 && prevDiff >= 0)) {
      count++;
      prevDiff = diff;
    }
  }
  // 返回摆动序列的长度
  return count;
};
```

## 最大子数组和
[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)
### 解题步骤 
1. 初始化两个变量，`sum` 和 `max`，并将它们设置为数组的第一个元素。
2. 遍历数组的剩余元素。对于数组中的每个元素：
    - 如果 `sum` 小于0，那么将 `sum` 更新为当前元素。这是基于的想法是，如果当前的和已经小于0，那么增加当前元素只会使得和更小。因此，最好是放弃前面的元素，从当前元素开始新的求和。
    - 否则，将当前元素加到 `sum` 上。
    - 如果 `sum` 大于 `max`，那么将 `max` 更新为 `sum`。这样，`max` 就始终保存了遍历到目前为止的最大子数组和。
3. 返回 `max`，它保存了最大的子数组和。

这个算法的时间复杂度是 O(n)，其中 n 是数组的长度。这是因为我们只需要遍历数组一次就可以找到最大的子数组和。
### 代码
#动态规划
```javascript
var maxSubArray = function (nums) {
  // 初始化 sum 和 max 为数组的第一个元素
  let sum = nums[0];
  let max = nums[0];

  // 遍历数组的剩余元素
  for (let i = 1; i < nums.length; i++) {
    // 如果当前的 sum 小于 0，我们就把 sum 更新为当前元素
    if (sum < 0) {
      sum = nums[i];
    } else {
      // 否则，我们就把当前元素加到 sum 上
      sum = sum + nums[i];
    }

    // 如果 sum 大于 max，我们就把 max 更新为 sum
    max = max < sum ? sum : max;
  }

  // 返回最大的子序和
  return max;
};
```

如果你想要在 `sum > 0` 时有不同的处理方式，你可以尝试下面的代码：
```javascript
var maxSubArray = function (nums) {
  // 初始化 sum 和 max 为数组的第一个元素
  let sum = nums[0];
  let max = nums[0];

  // 遍历数组的剩余元素
  for (let i = 1; i < nums.length; i++) {
    // 如果当前的 sum 大于 0，我们就把当前元素加到 sum 上
    if (sum > 0) {
      sum = sum + nums[i];
    } else {
      // 否则，我们就把 sum 更新为当前元素
      sum = nums[i];
    }

    // 如果 sum 大于 max，我们就把 max 更新为 sum
    max = max < sum ? sum : max;
  }

  // 返回最大的子序和
  return max;
};
```
- 动态规划版本:
```js
var maxSubArray = function(nums) {
    const n = nums.length
    let dp = Array(n).fill(null)
    dp[0] = nums[0]
    let max = dp[0]
    for (let i = 1; i < n; i++) {
        if (dp[i - 1] < 0) {
            dp[i] = nums[i]
        } else {
            dp[i] = dp[i - 1] + nums[i]
        }
        max = max > dp[i] ? max : dp[i]
    }
    return max
};
```
## 买卖股票的最佳时机 II
### 题目
给你一个整数数组 prices ，其中 `prices[i]` 表示某支股票第 i 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。
返回你能获得的最大利润。
[ 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)
### 思路
1. 动态规划
![Pasted image 20231003150414.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F10%2FPasted%20image%2020231003150414_20-49-57.png)
2. 贪心算法
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F10%2F20240110205245_20-52-46.png)

### 代码
1. 动态规划
```js
var maxProfit = function(prices) {
	let n=prices.length;
	let dp=new Array(n).fill(0).map(() =>new Array(2).fill(0));
	dp[0][0]=0;
	dp[0][1]=-prices[0]
	for(let i=1;i<prices.length;i++){
	dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
	dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
	}
	return dp[n-1][0]
};
//语义化
//语意化
function maxProfit(prices) {
  const len = prices.length;
  if (len < 2) {
    return 0;
  };
  let unhold = 0;	// 当天没有持有的情况下，最大的利润
  let hold = -prices[0]; // 当天持有的情况下，最大的利润
  for (let i = 1; i < len; i++) {
    const temp = unhold;  // 求今天的hold时，要用到昨天的unhold，暂存一下昨天的unhold
    unhold = Math.max(unhold, hold + prices[i]); // 求今天的unhold
    hold = Math.max(hold, temp - prices[i]);     // 求今天的hold
  }
  return unhold;
};
```
2. 贪心算法
```js
var maxProfit = function (prices) {
  let sum = 0;
  for (let left = 0; left < prices.length - 1; left++) {
    let right = left + 1;
    let profit = prices[right] - prices[left];
    if (profit > 0) {
      sum += profit;
    }
  }
  return sum;
};
```
## 跳跃游戏
### 题目
给你一个非负整数数组 nums ，你最初位于数组的第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
示例
	输入：nums = `[2,3,1,1,4]`
	输出：true
	解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
	[跳跃游戏](https://leetcode.cn/problems/jump-game/description/)
### 思路
- 从前往后
	使用贪心算法，从前往后遍历数组。在遍历过程中，
	我们维护一个覆盖范围，表示当前能够跳到的最远距离。
	每次遍历一个元素，我们都更新覆盖范围。
	如果覆盖范围已经包含了数组的最后一个元素，那么我们就可以提前结束遍历，返回 true。
	如果遍历完整个数组都没有找到能够跳到最后一个元素的方法，那么我们就返回 false。
- 从后往前
	是使用贪心算法，从后往前遍历数组。
	在遍历过程中，我们维护一个结束位置，表示当前需要到达的位置。每次遍历一个元素，我们都检查这个元素是否可以跳跃到结束位置。
	如果可以，我们就更新结束位置为当前元素的位置。
	这样，我们就可以一步步地将结束位置移动到数组的开始位置。
	如果结束位置最终为0，那么我们就可以从第一个元素跳跃到最后一个元素，返回 true。
	如果结束位置不为0，那么我们就不能从第一个元素跳跃到最后一个元素，返回 false。
### 代码
1. 从前往后
```js
// 贪心算法，从前往后考虑
var canJump = function (nums) {
  // 初始化覆盖范围为第一个元素的值
  let cover = nums[0];

  // 遍历数组，只要当前索引在覆盖范围内
  for (let i = 0; i <= cover; i++) {
    // 更新覆盖范围，取当前覆盖范围和当前索引加上当前元素值的最大值
    cover = Math.max(nums[i] + i, cover);

    // 如果覆盖范围已经大于等于数组的最后一个索引，说明可以跳到最后，返回true
    if (cover >= nums.length - 1) {
      return true;
    }
  }

  // 如果遍历完数组都没有返回true，说明不能跳到最后，返回false
  return false;
};
```
2. 从后往前
```js
var canJump = function (nums) {
  // 初始化结束位置为数组的最后一个元素的索引
  let end = nums.length - 1;

  // 从数组的倒数第二个元素开始向前遍历
  for (let i = nums.length - 2; i >= 0; i--) {
    // 如果当前元素可以跳跃的最远距离大于等于结束位置
    if (i + nums[i] >= end) {
      // 更新结束位置为当前元素的位置
      end = i;
    }
  }

  // 如果结束位置为0，说明可以从第一个元素跳跃到最后一个元素，返回true
  // 否则，返回false
  return end === 0;
};
```
## 跳跃游戏Ⅱ
### 题目
[跳跃游戏Ⅱ](https://leetcode.cn/problems/jump-game-ii/description/)
返回到达 `nums[n - 1]` 的最小跳跃次数
生成的测试用例可以到达 `nums[n - 1]`
### 思路
这个问题的解决思路是使用贪心算法。
我们从数组的开始位置出发，每次在当前能跳到的范围内选择一个能跳得最远的位置作为下一步的位置。
这样可以保证每次跳跃都能达到最远的距离，从而最小化跳跃次数。
### 代码
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function (nums) {
  let jumps = 0, // 记录跳跃次数
    currentJumpEnd = 0, // 当前跳跃能到达的最远位置
    farthest = 0; // 下一步跳跃能到达的最远位置
  for (let i = 0; i < nums.length - 1; i++) {
    farthest = Math.max(farthest, i + nums[i]); // 找到下一步跳跃能到达的最远位置
    if (i === currentJumpEnd) {
      // 如果当前位置已经达到了当前跳跃能到达的最远位置
      //如果最远位置大于数组长度,那么就不会触发这个条件
      jumps++; // 需要进行下一次跳跃
      currentJumpEnd = farthest; // 更新当前跳跃能到达的最远位置
    }
  }
  return jumps; // 返回跳跃次数
};
```

## K 次取反后最大化的数组和
### 题目
给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：
选择某个下标 i 并将 `nums[i]` 替换为 `-nums[i]` 。
重复这个过程恰好 k 次。可以多次选择同一个下标 i 。
以这种方式修改数组后，返回数组可能的最大和。
[1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/)
### 思路
- 分情况讨论
[贪心 + 分情况讨论 + 模拟-宫水三叶](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/solutions/1135524/gong-shui-san-xie-jian-dan-fen-qing-kuan-6qwu/)
首先，对数组进行升序排序，这样负数就会在数组的前面。
然后，遍历数组，统计负数的数量，记录0的存在，以及找出绝对值最小的元素的索引。
如果数组中没有负数
	那么就将数组中的前 k%2个元素取反(k 为偶,则不操作.k 为奇,第一个元素即绝对值最小的元素取反)。
如果数组中有负数的情况
	如果 k 小于负数的数量,只需要把前 k 个负数取反就可以了.
	如果 k 大于负数的数量,先将负数取反.如果剩余的操作数是奇数，并且数组中没有0，那么就将绝对值最小的元素取反。对于剩余操作数为偶数,则不需要处理.
最后，计算数组的和并返回。
### 代码
```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var largestSumAfterKNegations = function (nums, k) {
  nums.sort((a, b) => a - b); // 将数组按照升序排序
  let count = 0; // 记录负数的数量
  let idx = 0; // 记录绝对值最小的元素的索引
  let zero = false; // 记录数组中是否有0
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] < 0) count++; // 如果元素是负数，那么就增加负数的数量
    if (nums[i] == 0) zero = true; // 如果元素是0，那么就将zero设置为true
    if (Math.abs(nums[i]) < Math.abs(nums[idx])) idx = i; // 寻找最小的绝对值的索引
  }

  if (count === 0) { // 如果数组中没有负数
    for (let i = 0; i < k % 2; i++) { // 将数组中的前k%2个元素取反
      nums[i] = -nums[i];
    }
  } else { // 如果数组中有负数
    if (count >= k) { // 如果负数的数量大于等于k
      for (let i = 0; i < k; i++) { // 将数组中的前k个元素取反
        nums[i] = -nums[i];
      }
    }
    if (count < k) { // 如果负数的数量小于k
      for (let i = 0; i < count; i++) { // 将所有的负数都取反
        nums[i] = -nums[i];
      }
      if (!zero && (k - count) % 2 === 1) { // 如果剩余的操作数是奇数，并且数组中没有0
        nums[idx] = -nums[idx]; // 将绝对值最小的元素取反
      }
    }
  }
  let sum = nums.reduce((sum, cur) => sum + cur, 0); // 计算数组的和
  return sum; // 返回数组的和
};



```
更加简洁的版本
```js
var largestSumAfterKNegations = function(nums, k) {
    nums.sort((a, b) => a - b); // 将数组按照升序排序
    let sum = 0; // 初始化总和为0
    let idx = 0; // 记录绝对值最小的元素的索引
    let zero = false; // 记录数组中是否有0
    for (let i = 0; i < nums.length; i++) { // 遍历数组
        if (nums[i] < 0 && k > 0) { // 如果元素是负数，并且还有剩余的操作次数
            nums[i] = -nums[i]; // 将元素取反
            k--; // 减少剩余的操作次数
        }
        if (nums[i] == 0) zero = true; // 如果元素是0，那么就将zero设置为true
        if (Math.abs(nums[i]) < Math.abs(nums[idx])) idx = i; // 更新最小的绝对值的索引
        sum += nums[i]; 
    }
    if (k % 2 == 1 && !zero) { // 如果剩余的操作次数是奇数，并且数组中没有0
        sum -= 2 * nums[idx]; // 从总和中减去两倍的最小绝对值，因为之前加上了这个值
    }
    return sum; // 返回总和
};
```
第一次写题解,嘿嘿
作者：weiwu
链接： https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/solutions/2599934/javascript-fen-qing-kuang-tao-lun-tan-xi-ad2l/
## 加油站
### 题目
### 思路

#### 暴力法

这段代码的主要解题思路是：
1. 遍历每个加油站，尝试从每个加油站出发，看是否能够环绕一圈。

2. 对于每个加油站，计算出发后剩余的汽油量（初始为当前加油站的汽油量减去到下一个加油站的消耗）。

3. 然后，继续向下一个加油站前进，更新剩余的汽油量和当前的位置。

4. 如果在某个时刻剩余的汽油量小于0，那么就停止前进，并判断是否能够环绕一圈。

5. 如果能够环绕一圈，那么返回出发的加油站的编号，否则返回-1。

```javascript
var canCompleteCircuit = function (gas, cost) {
  for (let i = 0; i < gas.length; i++) { // 遍历每个加油站
    let rest = gas[i] - cost[i]; // 计算出发后剩余的汽油量
    let index = (i + 1) % gas.length; // 计算下一个加油站的编号
    while (rest > 0 && index != i) { // 如果剩余的汽油量大于0，并且没有环绕一圈
      rest = rest + gas[index] - cost[index]; // 更新剩余的汽油量
      index = (index + 1) % gas.length; // 更新当前的位置
    }
    if (rest >= 0 && index == i) { // 如果剩余的汽油量大于等于0，并且已经环绕一圈
      return i; // 返回出发的加油站的编号
    }
  }
  return -1; // 如果没有找到合适的出发点，返回-1
};

gas = [1, 2, 3, 4, 5];
cost = [3, 4, 5, 1, 2];
console.log(canCompleteCircuit(gas, cost)); // 输出：3
```


> [!summary] 从数组末尾转至首位
>除以数组长度取余
>let index = (i + 1) % gas.length;

#### 贪心 (局部最优)
**思路来自于[笨猪爆破组大佬](https://leetcode.cn/problems/gas-station/solutions/488498/shou-hua-tu-jie-liang-ge-guan-jian-jie-lun-de-jian)**
每个站的剩余油量累加给 left，即 `left += gas[i]-cost[i]`，如果 left 一直大于0，则可以一直走下去，如果出现了小于0，说明到不了下一站。
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F14%2F20240114095136_09-51-37.png)
- 结论1
如果 left 累加 `gas[i]−cost[i]` 后，小于 0.则出发点到站 i 之间的所有点都不是起点。

- 结论2
如果总加油量 sum(gas)>=sum(cost)sum(gas) >= sum(cost)sum(gas)>=sum(cost) 总耗油量，问题一定有解。
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F14%2F20240114095318_09-53-18.png)
- 代码
```js
var canCompleteCircuit = function(gas, cost) {
    let totalGas = 0;
    let totalCost = 0;
    let start = 0;
    let tank = 0;

    for (let i = 0; i < gas.length; i++) {
        totalGas += gas[i]; // 计算所有加油站的汽油总量
        totalCost += cost[i]; // 计算总的行驶消耗
        tank += gas[i] - cost[i]; // 计算从当前的出发点到这个加油站的剩余汽油量
        if (tank < 0) { // 如果剩余的汽油量小于0
            start = i + 1; // 将出发点设置为下一个加油站
            tank = 0; // 将剩余的汽油量重置为0
        }
    }

    if (totalGas < totalCost) { // 如果汽油总量小于总的行驶消耗
        return -1; // 返回-1
    } else {
        return start; // 返回出发点
    }
};

gas = [1, 2, 3, 4, 5];
cost = [3, 4, 5, 1, 2];
console.log(canCompleteCircuit(gas, cost)); // 输出：3
```

**ps**:tank 是油箱的意思

## 柠檬水找零
### 题目
### 思路 &&代码
- 主要解题思路
使用贪心算法。我们需要尽可能地给顾客找零10美元，因为10美元的零钱更有限。我们遍历账单，对于每一位顾客，如果他支付了5美元，我们就收下；如果他支付了10美元，我们就找回5美元；如果他支付了20美元，我们优先找回10美元和5美元，如果没有10美元，就找回3个5美元。如果在任何时候我们不能找零，我们就返回 false。

- 代码

```javascript
/**
 * @param {number[]} bills
 * @return {boolean}
 */
var lemonadeChange = function (bills) {
  let five = 0; // 5美元的数量
  let ten = 0; // 10美元的数量
  for (let i = 0; i < bills.length; i++) {
    if (bills[i] === 5) { // 如果顾客支付了5美元
      five++; // 我们收下
    } else if (bills[i] === 10) { // 如果顾客支付了10美元
      if (five === 0) { // 如果我们没有5美元的零钱
        return false; // 我们不能找零
      }
      five--; // 我们找回5美元
      ten++; // 我们收下10美元
    } else if (bills[i] === 20) { // 如果顾客支付了20美元
      if (ten > 0 && five > 0) { // 如果我们有10美元和5美元的零钱
        ten--; // 我们找回10美元
        five--; // 我们找回5美元
      } else if (five >= 3) { // 如果我们有3个5美元的零钱
        five -= 3; // 我们找回3个5美元
      } else { // 如果我们没有足够的零钱
        return false; // 我们不能找零
      }
    }
  }
  return true; // 如果我们可以给每一位顾客找零，我们返回true
};
```

这段代码的时间复杂度是 O(n)，因为我们需要遍历每一位顾客。空间复杂度是 O(1)，因为我们只使用了常数级别的额外空间。

## 435. 无重叠区间
### 题目
- 题目链接
[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/description/)
- 题目描述
	输入: `intervals = [[1,2],[2,3],[3,4],[1,3]]`
	输出: 1
	解释: 移除 `[1,3]` 后，剩下的区间没有重叠。
- 比较好的题解
### 思路
- 参考[代码随想录](https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)
1. 按照右边界排序,从左到右记录非交叉区间的个数.
2. 区间总数减去非交叉区间的个数
- 示意图
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F15%2F20240115210030_21-00-30.png)
区间，1，2，3，4，5，6都按照右边界排好序。

当确定区间 1 和区间2 重叠后，如何确定是否与区间3 也重贴呢？

就是取区间1 和区间2 右边界的最小值，因为这个最小值之前的部分一定是区间1 和区间2 的重合部分，如果这个最小值也触达到区间3，那么说明区间 1，2，3都是重合的。

接下来就是找大于区间1结束位置的区间，是从区间4开始。那有同学问了为什么不从区间5开始？别忘了已经是按照右边界排序的了。

区间4结束之后，再找到区间6，所以一共记录非交叉区间的个数是三个。

总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。
### 代码
- 计算交叉区间的个数
```js
var eraseOverlapIntervals = function(intervals) {
    if (intervals.length === 0) {
        return 0;
    }

    // 对区间按照结束时间进行升序排序
    intervals.sort((a, b) => a[1] - b[1]);

    // 初始化结束时间为第一个区间的结束时间
    let end = intervals[0][1];

    // 初始化计数器为0，表示当前没有交叉的区间
    let count = 0;

    // 遍历区间，从第二个区间开始
    for (let i = 1; i < intervals.length; i++) {
        // 如果当前区间的开始时间小于上一个区间的结束时间，说明这两个区间重叠
        if (intervals[i][0] < end) {
            // 增加计数器
            count++;
        } else {
            // 如果当前区间的开始时间大于等于上一个区间的结束时间，说明这两个区间不重叠
            // 更新结束时间为当前区间的结束时间
            end = intervals[i][1];
        }
    }

    // 返回交叉的区间数量
    return count;
};
```
- 计算非交叉区间的个数
需要预置为1
```js
var eraseOverlapIntervals = function (intervals) {
  // 对区间按照结束时间进行升序排序
  intervals.sort((a, b) => a[1] - b[1]);

  // 初始化结束时间为第一个区间的结束时间
  let end = intervals[0][1];

  // 初始化计数器为1，表示至少有一个区间不重叠
  let count = 1;

  // 遍历区间，从第二个区间开始
  for (let i = 1; i < intervals.length; i++) {
    // 如果当前区间的开始时间小于上一个区间的结束时间，说明这两个区间重叠
    if (intervals[i][0] < end) {
      // 更新结束时间为当前区间和上一个区间结束时间的最小值，这样可以使得后面的区间有更大的可能性不与当前区间重叠
      end = Math.min(intervals[i][1], end);
    } else {
      // 如果当前区间的开始时间大于等于上一个区间的结束时间，说明这两个区间不重叠
      // 更新计数器
      count++;
      // 更新结束时间为当前区间的结束时间
      end = intervals[i][1];
    }
  }
  // 返回需要移除的区间数量，即总的区间数量减去不重叠的区间数量
  return intervals.length - count;
};
```

## 合并区间
### 题目
以数组 intervals 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。
[56.合并区间](https://leetcode.cn/problems/merge-intervals/description/)
### 思路
[笨猪爆破组的题解](https://leetcode.cn/problems/merge-intervals/solutions/487031/shou-hua-tu-jie-56he-bing-qu-jian-by-xiao_ben_zhu/)
- prev 初始为第一个区间，cur 表示当前的区间，res 表示结果数组
- 开启遍历，尝试合并 prev 和 cur，合并后更新到 prev
- 合并后的新区间还可能和后面的区间重合，继续尝试合并新的 cur，更新给 prev
- 直到不能合并 —— `prev[1] < cur[0]`，此时将 prev 区间推入 res 数组
**合并策略**
原则上要更新 `prev[0]`和 `prev[1]`，即左右端:
`prev[0] = min(prev[0], cur[0])`
`prev[1] = max(prev[1], cur[1])`
但如果先按区间的左端排升序，就能保证 `prev[0] < cur[0]`
所以合并只需这条：`prev[1] = max(prev[1], cur[1])`
**易错点**
我们是先合并，遇到不重合再推入 prev。
当考察完最后一个区间，后面没区间了，遇不到不重合区间，最后的 prev 没推入 res。
要单独补上。
### 代码
```js
var merge = function (intervals) {
  intervals.sort((a, b) => a[0] - b[0]);
  let prev = intervals[0];
  let res = [];
  for (let i = 1; i < intervals.length; i++) {
    let cur = intervals[i];
    if (prev[1] >= cur[0]) {
      //重合
      prev[1] = cur[1];
    } else {
      //不重合
      res.push(prev);
      prev = cur;
    }
  }
  // 遍历结束之后两种情况
  // case 1 最后一个区间被合并，则需要将current添加到结果集
  // case 2 最后一个区间没有被合并，也需要将current添加到结果集
  res.push(prev);
  return res;
};
```
### 实现删除数组第一个元素

## 单调递增的数字(Monotone Increasing Digits)
### 题目描述
当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是单调递增的。
给定一个整数 n ，返回小于或等于 n 的最大数字，且数字呈单调递增。
### 思路 && 代码
- 思路
主要思路是从右向左遍历数字的每一位，找到第一个非单调递增的位置，然后将这个位置左边的数字减1，将这个位置及其右边的所有数字都设置为9。这样可以保证结果是小于或等于 n 的最大的单调递增数字。
- 代码
```js
var monotoneIncreasingDigits = function (n) {
  const str = n.toString();
  const strArray = str.split('');// 将n转为字符串数组
  let index = strArray.length - 1;
  let flag = 0;
  for (let i = strArray.length - 1; i >= 1; i--) {
    // 如果当前数字小于前一个数字
    if (strArray[i] < strArray[i - 1]) {
      // 减1并更新索引和标志位
      strArray[i - 1] = strArray[i - 1] - '1';//返回number类型
      index = i;
      flag = 1;
    }
  }
  // 如果存在非单调递增的位置，将该位置及其右边的所有数字都设置为'9'
  if (flag) {
    for (let i = index; i <= strArray.length - 1; i++) {
      strArray[i] = '9';
    }
  }
  // 如果首位是0，删除它
  if (strArray[0] === 0) {
    strArray.shift();
  }

  // 返回结果
  return strArray.join('');
};
```
### unfamiliar:数字转字符串
```js
const str = n.toString();
```
### unfamiliar:字符串转数组
```js
const strArray = str.split('');
```
### notice:字符串-"1"=number
```js
strArray[i - 1] = strArray[i - 1] - '1';//返回number类型
//
//"5"-"1"=4
```
# 动态规划 Dynamic planning
## Climbing Stairs
### 题目
### 思路
- 简单思考
爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。

那么第一层楼梯再跨两步就到第三层，第二层楼梯再跨一步就到第三层。

所以到第三层楼梯的状态可以由第二层楼梯和到第一层楼梯状态推导出来，那么就可以想到动态规划了。
- 动规五部曲：
定义一个一维数组来记录不同楼层的状态

1. 确定 dp 数组以及下标的含义
`dp[i]`： 爬到第 i 层楼梯，有 `dp[i]`种方法

2. 确定递推公式
如何可以推出 `dp[i]`呢？

从 `dp[i]`的定义可以看出，`dp[i]` 可以有两个方向推出来。

首先是 `dp[i - 1]`，上 i-1层楼梯，有 `dp[i - 1]`种方法，那么再一步跳一个台阶不就是 `dp[i]`了么。

还有就是 `dp[i - 2]`，上 i-2层楼梯，有 `dp[i - 2]`种方法，那么再一步跳两个台阶不就是 `dp[i]`了么。

那么 `dp[i]`就是 `dp[i - 1`]与 `dp[i - 2]`之和！

所以 `dp[i] = dp[i - 1] + dp[i - 2]` 。

在推导 `dp[i]`的时候，一定要时刻想着 `dp[i]`的定义，否则容易跑偏。

这体现出确定 dp 数组以及下标的含义的重要性！

3. dp 数组如何初始化
再回顾一下 `dp[i]`的定义：爬到第 i 层楼梯，有 `dp[i]`种方法。

那么 i 为0，`dp[i]`应该是多少呢，这个可以有很多解释，但基本都是直接奔着答案去解释的。

例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：`dp[0] = 1`，相当于直接站在楼顶。

但总有点牵强的成分。

那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，`dp[0]`就应该是0.

其实这么争论下去没有意义，大部分解释说 `dp[0]`应该为1的理由其实是因为 `dp[0]=1`的话在递推的过程中 i 从2开始遍历本题就能过，然后就往结果上靠去解释 `dp[0] = 1`。

从 dp 数组定义的角度上来说，`dp[0] = 0` 也能说得通。

需要注意的是：题目中说了 n 是一个正整数，题目根本就没说 n 有为0的情况。

所以本题其实就不应该讨论` dp[0]`的初始化！

我相信 `dp[1] = 1`，`dp[2] = 2`，这个初始化大家应该都没有争议的。

所以我的原则是：不考虑 `dp[0]`如何初始化，只初始化 `dp[1] = 1`，`dp[2] = 2`，然后从 i = 3开始递推，这样才符合` dp[i]`的定义。

4. 确定遍历顺序
从递推公式 `dp[i] = dp[i - 1] + dp[i - 2]`;中可以看出，遍历顺序一定是从前向后遍历的

5. 举例推导 dp 数组
举例当 n 为5的时候，dp table（dp 数组）应该是这样的:下标 `1,2,3,4,5 -->1,2,3,5,8`

### 代码
```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
  let dp = [];
  dp[1] = 1;
  dp[2] = 2;
  if (n === 1) return dp[1];
  if (n === 2) return dp[2];
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
};
```
- 优化
```js
var climbStairs = function (n) {
  let dp = [];
  dp[1] = 1;
  dp[2] = 2;
  if (n === 1) return dp[1];
  if (n === 2) return dp[2];
  for (let i = 3; i <= n; i++) {
    let sum = dp[1] + dp[2];
    dp[1] = dp[2];
    dp[2] = sum;
  }
  return dp[2];
};
```
## 使用最小花费爬楼梯
### 题目描述
给你一个整数数组 cost ，其中 `cost[i]` 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。
[746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)
### 思路
![image.png|500](https://cdn.jsdelivr.net/gh/fencesitter1/pictures/img/2024%2F01%2F23%2F20240123105459_10-54-59.png)

### 代码
```js
var minCostClimbingStairs = function (cost) {
  let dp = [];
  dp[0] = 0;
  dp[1] = 0;
  for (let i = 2; i <= cost.length; i++) {
    dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
  }
  return dp[cost.length];
};```
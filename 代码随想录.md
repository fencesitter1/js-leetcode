```toc
```
# 本地环境搭建
## 自定义代码片段
如果你想在 VSCode 中避免每次都写相同的起始代码，你可以创建一个代码片段（Snippet）。代码片段是一小段预定义的代码，通过简单的快捷键或者其他触发方式就可以插入到你的代码中。
在 VSCode 中，你可以创建自定义的代码片段。以下是一个简单的例子，演示如何创建一个代码片段来导入 readline-sync 和设置默认选项：
1. 打开 VSCode，进入你的项目。
2. 在左侧资源管理器中，右键点击 `.vscode` 文件夹（如果没有，请新建一个），然后选择 "New File"，创建一个名为 `code-snippets.json` 的文件。
3. 在 `code-snippets.json` 文件中添加以下内容：

```json
{
  "Readline Setup": {
    "prefix": ["readline", "setup"],
    "body": [
      "var __readline = require(\"readline-sync\");",
      "__readline.setDefaultOptions({ prompt: \"\" });",
      "var readline = __readline.prompt;"
    ],
    "description": "Setup readline-sync"
  }
}
```
这个 JSON 文件定义了一个名为 "Readline Setup" 的代码片段。当你在代码中输入 `readline setup` 时，按下 `Tab` 键，它会自动展开为你想要的 readline-sync 设置代码。

4. 保存 `code-snippets.json` 文件。
现在，当你在你的代码中输入 `readline setup`，然后按下 `Tab` 键，就会自动生成 readline-sync 设置的代码。

# 数组
## 二分查找
```js
var search = function(nums, target) {
    // right是数组最后一个数的下标，num[right]在查找范围内，是左闭右闭区间
    let mid, left = 0, right = nums.length - 1;
    // 当left=right时，由于nums[right]在查找范围内，所以要包括此情况
    while (left <= right) {
        // 位运算 + 防止大数溢出
        mid = left + ((right - left) >> 1);
        // 如果中间数大于目标值，要把中间数排除查找范围，所以右边界更新为mid-1；如果右边界更新为mid，那中间数还在下次查找范围内
        if (nums[mid] > target) {
            right = mid - 1;  // 去左面闭区间寻找
        } else if (nums[mid] < target) {
            left = mid + 1;   // 去右面闭区间寻找
        } else {
            return mid;
        }
    }
    return -1;
};
```
## 移除元素
[移除元素](https://leetcode.cn/problems/remove-element/solutions/)
1. 思路:快慢指针
```js
var removeElement = function(nums, val) {
    let slow=0;
    for(let fast=0;fast<nums.length;fast++){
        if(nums[fast]!=val){
            nums[slow]=nums[fast];
            slow++;
        }
    }
    return slow;
};
```
## [长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)
- 思路:
	滑动窗口法
```js
var minSubArrayLen = function(target, nums) {
    let start, end
    start = end = 0
    let sum = 0
    let len = nums.length
    let ans = Infinity
    
    while(end < len){
        sum += nums[end];
        while (sum >= target) {
            ans = Math.min(ans, end - start + 1);
            sum -= nums[start];
            start++;//左指针滑动
        }
        end++;
    }
    return ans === Infinity ? 0 : ans
};
```
## 螺旋矩阵 II
[螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/solutions/659084/ru-guo-ni-yuan-yi-yi-ceng-yi-ceng-yi-cen-cm9h/)
### 思路:
我们开始的思路都是一样的按照从左到右从上到下从右到左从下到上的顺序遍历这个二维数组，但是边界条件很难把控,导致晕头转向
我们可以发现在每遍历完一条边后边界都会收缩,如第一次循环的起点是从(0,0)开始的,第二次的话就会从(1,1)开始,当边界收缩到上边界>下边界或左边界>右边界时,我们就可以说我们将这个数组遍历完了
所以我们可以设置 t(上边界)、r(右边界)、b(下边界)、l(左边界),每次遍历完一条边后向内收缩 t++ / r-- / b-- / l++,当收缩到 t > b 或 l > r 时则说明我们完成了一整个矩阵的循环
此思路同样适用于54题

```js
var generateMatrix = function (n) {
  const matrix = new Array(n);
  for (let i = 0; i < n; i++) {
    matrix[i] = new Array(n);
  }
  let num = 1;
  let left = 0;
  let right = n - 1;
  let top = 0;
  let bottom = n - 1;
  while (left <= right && top <= bottom) {
  //while(num<=n*n)
    for (i = left; i <= right; i++) {
      matrix[top][i] = num;
      num++;
    }
    top++;

    for (i = top; i <= bottom; i++) {
      matrix[i][right] = num;
      num++;
    }
    right--;
    for (i = right; i >= left; i--) {
      matrix[bottom][i] = num++;
    }
    bottom--;
    for (i = bottom; i >= top; i--) {
      matrix[i][left] = num++;
    }
    left++;
  }
  return matrix;
};
```
## JS 二维数组

```js
let arr=new Array(n).fill(0).map(() => new Array(n).fill(0))
```

# 链表
## 移除链表元素
[203.移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)
```js
var removeElements = function(head, val) {
  const dummy=new ListNode(0);
  dummy.next=head;
  let cur=dummy;
  while(cur.next!=null){
    cur.next.val==val ? cur.next=cur.next.next:cur=cur.next
  }

  return dummy.next
  };
```
## 设计链表
- 时间：2023-11-26
### 法一:双指针法
```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
 let temp=null;pre=null;cur=head;
 while(cur){
     temp=cur.next;
     cur.next=pre;
     pre=cur;
     cur=temp;
 }
 return pre;
};
```
## 两两交换链表中的节点
[leetcode24.](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)
```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    let dummy=new ListNode(0,head);//定义一个虚拟空节点
    let cur=dummy;
    while(cur.next&&cur.next.next){
        let n1=cur.next;
        let n2=cur.next.next;
        cur.next=n2;
        n1.next=n2.next;
        n2.next=n1;
        cur=n1;
    }
    return dummy.next;
}
```

## 19.删除链表的倒数第 N 个节点
[leetcode19](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)
### 快慢指针(双指针)
需要注意的是 n ，快慢指针间隔为 n+1
```js
var removeNthFromEnd = function(head, n) {
  let dummy=new ListNode(0, head);
  let fast=dummy;slow=dummy;
  for(let i=0;i<=n;i++){//这里小于等于n
    fast=fast.next;
  }
  while(fast){
    fast=fast.next;
    slow=slow.next;
  }
  slow.next=slow.next.next;
  return dummy.next;
  };
```

## 面试题 02.07. 链表相交
[面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)
- 法一:前端对齐
```js
// 2. 前端对齐
// 考虑到重复的链表节点一定一样长，所以只需要从后往前保留一样长度即可
var getIntersectionNode = function(headA, headB) {
    // 先计算两个链表的长度分别是多少
    let la = 0
    let lb = 0
    let a = headA
    let b = headB
    while (a) {
      la ++
      a = a.next
    }
    while (b) {
      lb ++
      b = b.next
    }

    // 计算两个链表的长度差异，找出较长的链表
    let diff = Math.abs(la - lb)
    let large = null
    let small = null
    if (la > lb) {
      large = headA
      small = headB
    } else {
      large = headB
      small = headA
    }

    // 把较长的链表前端先剪切掉差异的数量，让两个链表长度一齐
    for (let i = 0;i < diff;i ++) {
      large = large.next
    }

    // 双指针一起遍历，找到第一个一样的即可
    while (large !== small) {
      large = large.next
      small = small.next
    }
    return large
};
```

## 142.环形链表Ⅱ
#快慢指针
### 快慢指针
[题解 angela:](https://leetcode.cn/problems/linked-list-cycle-ii/solutions/1083013/tu-jie-kuai-man-zhi-zhen-ji-qiao-yuan-li-5tz0/)
[题解:krahets](https://leetcode.cn/problems/linked-list-cycle-ii/solutions/12616/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/)
```js
var detectCycle = function(head) {
  // 快慢指针初始化指向 head
  let slow = head;
  let fast = head;
  // 快指针走到末尾时停止
  while (fast && fast.next) {
    // 慢指针走一步，快指针走两步
    slow = slow.next;
    fast = fast.next.next;
    // 快慢指针相遇，说明含有环
    if (slow == fast) {
      // 任一一节点指向头节点
      fast = head;
      // 同步向前进
      while (fast != slow) {
        fast = fast.next;
        slow = slow.next;
      }
      // 返回入口节点
      return fast;
    }
  }
  // 不包含环
  return null;   
};

作者：angela
链接：https://leetcode.cn/problems/linked-list-cycle-ii/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
### 哈希表
```js
var detectCycle = function(head) {
  let map=new Map();
  while(head){
    if(map.has(head)){
      return head
    }else{
      map.set(head,true);
      head=head.next;
    }
  }
  return null
};
```



## 876.链表的中间节点
[876.链表的中间节点](https://leetcode.cn/problems/middle-of-the-linked-list/description/)
- 思路
	求中间节点，除了暴力法，先求链表长度 length；一定要想到用双指针！
	用快指针 q 每次走2步；慢指针 p 每次走1步；
	这样走到终点，慢指针 p 就处于中间位置；
```js
var middleNode = function(head) {
 let n1=head;
 let n2=head;
 while(n2&&n2.next){
    n1=n1.next;
    n2=n2.next.next;
 }
 return n1
};
```
- 注意点
`while(n2)` 会出错, `TypeError: Cannot read properties of null (reading 'next')`.原因在于 `n2.Next` 可能是 null，null 不存在下一个节点
## 141.环形链表
[141.环形链表](https://leetcode.cn/problems/linked-list-cycle/solutions/261191/lei-si-xiao-xue-de-zhui-ji-wen-ti-kuai-man-zhi-zhe/)
### 快慢指针
```js
var hasCycle = function(head) {
    let n1=head;
    let n2=head;
    while(n2&&n2.next){
      n1=n1.next;
      n2=n2.next.next;
      if(n1==n2){
        return true;
      }
    }
  return false;
};
```
### 哈希表
```js
var hasCycle = function(head) {
let  map=new Map();
while(head){
  if(map.has(head)){
    return true
  }else{
    map.set(head,true);
    head=head.next;
  }
}
return false
};
```


## 回文链表
[回文链表](https://leetcode.cn/problems/palindrome-linked-list/solutions/457288/shou-hua-tu-jie-hui-wen-lian-biao-kuai-man-zhi-zhe/?envType=study-plan-v2&envId=top-100-liked)题解
```js
const isPalindrome = (head) => {
  if (head == null || head.next == null) {
    return true;
  }
  let fast = head;
  let slow = head;
  let prev;
  while (fast && fast.next) {
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }
  prev.next = null;  // 断成两个链表
  // 翻转后半段
  let head2 = null;
  while (slow) {
    const tmp = slow.next;
    slow.next = head2;
    head2 = slow;
    slow = tmp;
  }
  // 比对
  while (head && head2) {
    if (head.val != head2.val) {
      return false;
    }
    head = head.next;
    head2 = head2.next;
  }
  return true;
};
```
![|650](photo&pdf/Pasted%20image%2020231129152310.png)
![|650](photo&pdf/Pasted%20image%2020231129152326.png)

# 哈希表
**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**
## 有效的字母异位词

```js
/**
 * @description: 数组   TC:O(n)  SC:O(1)
 * @author: JunLiangWang
 * @param {*} s 给定字符串s
 * @param {*} t 给定字符串t
 * @return {*}
 */
/1.排序后比较字符串是否相等
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function (s, t) {
  if (s.length != t.length) return false;
  // 这里必须得用join去比较  不然比较的是引用对象  不管怎么样都不会相等的
  return [...s].sort().join("") == [...t].sort().join("");
};

/2.
function array(s, t) {
    /**
     * 本题使用数组的方式，由于字符串中仅
     * 存在小写字母，因此我们可以通过构建
     * 一个26位的数组，利用数组记录字符串
     * 中a-z的字符数量即可
     */
    // 如果两者长度不一致，肯定不为字母异位词
    if (s.length != t.length) return false
    // 定义一个26位的数组记录单词数量
    let wordList = new Array(26).fill(0)
    // 遍历字符串
    for (let i = 0; i < s.length; i++) {
        // 记录单词数量
        wordList[s.charCodeAt(i) - 97]++;
        wordList[t.charCodeAt(i) - 97]--;
    }
    // 遍历数组，如果某个单词数量不为0，则
    // 证明两字符串中该单词数量不一样
    for (let i = 0; i < 26; i++)if (wordList[i] != 0) return false
    return true
}



/**
 * @description: 哈希表  TC:O(n)  SC:O(n)
 * @author: JunLiangWang
 * @param {*} s 给定字符串s
 * @param {*} t 给定字符串t
 * @return {*}
 */
function hashMap(s, t) {
    /**
     * 本题使用哈希表的方式，与上述使用
     * 数组的方式思路一样，利用哈希表记
     * 录字符串中单词的数量
     */

    // 如果两者长度不一致，肯定不为字母异位词
    if (s.length != t.length) return false
    // 定义哈希表
    let map = new Map
    // 遍历字符串s，在hashMap中记录单词
    for (let i = 0; i < s.length; i++) {
        let count = map.get(s[i])
        map.set(s[i], count == undefined ? 1 : count + 1)
    }
    // 遍历字符串t
    for (let i = 0; i < t.length; i++) {
        let count = map.get(t[i])
        // 如果hashMap中单词数量为0，或没有
        // 这个单词，证明两字符单词数量不一致
        if (count == 0 || count == undefined) return false
        map.set(t[i], count - 1)
    }
    // 遍历hashMap，如果存在数量不为0的单词
    // 证明两字符单词数量不一致
    for (let key in map) if (map.get(key) != 0) return false

    return true
}
```

## 349. 两个数组的交集
[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)
[题解1](https://leetcode.cn/problems/intersection-of-two-arrays/solutions/1119239/349-liang-ge-shu-zu-de-jiao-ji-by-chen-w-p6dl/)
- 法1：集合 Set
```js
var intersection = function (nums1, nums2) {
    let set1 = new Set(nums1);
    let set2 = new Set(nums2);//数组转成set
    //if (set1.size > set2.size) {//用size小的数组遍历
    //    [set1, set2] = [set2, set1]
    //}
    const intersection = new Set();
    for (const num of set1) {//遍历set1
        if (set2.has(num)) {//元素如果不存在于set2中就加入intersection
            intersection.add(num);
        }
    }
    return [...intersection];//转成数组
};
```
没用必要进行数组的大小比较，因为 `set.Add()` 会自动去重,set 只保留不重复的值

> [!info] 找出较长/短的集合
```js
    if (set1.size > set2.size) {//用size小的数组遍历
        [set1, set2] = [set2, set1]
    }
    //set1永远是较短的那一个
```

## 快乐数
[快乐数](https://leetcode.cn/problems/happy-number/description/)
### 解题思路
有快乐数，形成不了循环。
没有快乐数，形成环路，造成死循环。

> [!example] 法一:哈希表 set /map
```js
/**
 * 解法1：哈希法
 * 缺点是用到哈希集合，空间复杂度过高
 */
const getSum = n => {
    let sum = 0
    while (n) {
        sum += (n % 10) ** 2
        n = Math.floor(n / 10)
    }
    return sum
}
var isHappy = function (n) {
    // Set写法
    let ret = new Set()
    while (1) {
        if (ret.has(n)) return false
        if (n === 1) return true
        ret.add(n)
        n = getSum(n)
    }
    // Map写法
    // let ret = new Map()
    // while (1) {
    //     if (ret.has(n)) return false
    //     if (n === 1) return true
    //     ret.set(n, 1)
    //     n = getSum(n)
    // }
};
```
> [!example] 法2:快慢指针 
```js 
/**
 * 解法2：快慢指针，与判断环形链大同小异
 * 比哈希解法好太多了，时间空间复杂度都很低
 */
const getSum = n => {
    let sum = 0
    while (n) {
        sum += (n % 10) ** 2
        n = Math.floor(n / 10)
    }
    return sum
}
var isHappy = function (n) {
    let slow = getSum(n), fast = getSum(getSum(n))
    while (slow !== fast) {
        slow = getSum(slow)
        fast = getSum(getSum(fast))
    }
    // 判断是否是因为1引起的循环，是的话就是快乐数，不是就代表非快乐数死循环
    return slow === 1
};
```

## 两数之和
[题目描述](https://leetcode.cn/problems/two-sum/description/)
[灵神题解](https://leetcode.cn/problems/two-sum/solutions/2326193/dong-hua-cong-liang-shu-zhi-he-zhong-wo-0yvmj/) 有一个动图对于理解很棒！
> [!example] 哈希表
> 本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value 结构来存放，key 来存元素，value 来存下标，那么使用 map 正合适。
```js
var twoSum = function (nums, target) {
    let idx = new Map(); // 创建一个空哈希表
    for (let j = 0; ; j++) { // 枚举 j
        const x = nums[j];
        // 在左边找 nums[i]，满足 nums[i]+x=target
        if (idx.has(target - x)) // 找到了
            return [idx.get(target - x), j]; // 返回两个数的下标
        idx.set(x, j); // 保存 nums[j] 和 j
    }
};

作者：灵茶山艾府
链接：https://leetcode.cn/problems/two-sum/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```


### 思路总结
> [!summary] 
>
很多涉及到「**两个变量**」的题目，都可以枚举其中一个变量，把它当成常量看待，从而转换成「一个变量」的问题。
代码实现时，通常来说「枚举右，寻找左」是更加好写的。
### 类似题(两个变量)
1. [1010. 总持续时间可被 60 整除的歌曲](https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/description/)
- 解题思路:
	`(a+b) % 60 === 0`，等价于 `(a%60 + b%60) % 60 === 0;`
	余数相加模60等于0,类似于两数相加
	`x=a%60,y=b%60`
	这里 `(x+y) % 60 = 0`，其中 `0<=x,y<60`，那么有两种情况：1. x+y=60; 2. x+y=0，这两种情况可以合并为：`y=(60-x) % 60`
- 代码:
```js
var numPairsDivisibleBy60 = function (time) {
  let map = new Map();
  let res = 0;
  for (i = 0; i < time.length; i++) {
    let x = time[i] % 60;
    let y = x==0? 0:60-x;
    if (map.has(y)) {
      res += map.get(y);
    }
    if (map.has(x)) {
      map.set(x, map.get(x) + 1);
    }
    if (!map.has(x)) {
      map.set(x, 1);
    }
  }
  return res;
};
```
y 当作移动指针，在左边寻找

## 四数相加Ⅱ
[四数相加Ⅱ](https://leetcode.cn/problems/4sum-ii/description/)
### 思路
主要是转化为两数之和

a+b 建一个表，key 为和，value 为次数。 c+d 遍历查表，看有没有等于 0- (c+d)的本题需要统计符合条件的元素组合数量，搞个 count 变量来记录查表结果即可
## 代码
```js
var fourSumCount = function (nums1, nums2, nums3, nums4) {
  let map = new Map();
  for (const a of nums1) {
    for (const b of nums2) {
      let sum = a + b;
      if (map.has(sum)) {
        map.set(sum, map.get(sum)+ 1);
      } else {
        map.set(sum, 1);
      }
    }
  }
  let result=0;
  for(const c of nums3){
    for(const d of nums4){
      let sum1=-(c+d);
      result+=map.has(sum1)? map.get(sum1):0
    }
  }
  return result
};
```

## 383.赎金信
题目: [赎金信](https://leetcode.cn/problems/ransom-note/description/)
```js
var canConstruct = function(ransomNote, magazine) {
    let arr1=[...ransomNote];
    let arr2=[...magazine];
    let map=new Map();
    for(const a of arr2){
        map.has(a)?map.set(a,map.get(a)+1):map.set(a,1);
    }
    for(const b of arr1){
        if(map.has(b)){
            map.set(b,map.get(b)-1);
            if(map.get(b)<0){
                return false;
            }
        }
        if(!map.has(b)) return false;
    }
    return true
};
```

## 三数之和
**题目**:
### 解题思路:
数组排序加双指针
### 代码:
```js
var threeSum = function (nums) {
  let len = nums.length;
  let result = [];
  nums.sort((a, b) => a - b);
  for (let i = 0; i < len - 2; i++) {
    let left = i + 1;
    let right = len - 1;
    if(i>0 && nums[i]==nums[i-1]) continue;//去重
    while (left<right) {
      let sum = nums[i] + nums[left] + nums[right];
      if (sum > 0 || nums[right]==nums[right+1]) right--;
      if (sum < 0 ) left++;
      if (sum == 0) {
        result.push([nums[i], nums[left], nums[right]]);
        left++;
        right--;
        //这里指针的去重一开始没考虑
        //去重逻辑应该放在找到一个三元组之后，对left和right去重
        while(nums[left]===nums[left-1]) left++;
        while(nums[right]===nums[right+1]) right++;
      }
    }
  }
  return result;
};
```

> [!NOTE] 注意点:去重
> 对于重复元素的跳过，首先是 i，其次是左右指针的去重。

## 四数之和

### 解题思路:

### 代码:
```js
var fourSum = function (nums, target) {
  let res = [];
  let len = nums.length;
  nums.sort((a, b) => a - b);
  for (let i = 0; i < len - 3; i++) {
    if (i > 0 && nums[i] == nums[i - 1]) continue;
    for (let j = i + 1; j < len - 2; j++) {
      if (j > i + 1 && nums[j] == nums[j - 1]) continue;
      let left = j + 1;
      let right = len - 1;
      while (left < right) {
        let sum = nums[i] + nums[j] + nums[left] + nums[right];
        if (sum == target) {
          res.push([nums[i], nums[j], nums[left], nums[right]]);
          left++;
          right--;
          while (nums[left] === nums[left - 1]) left++;
          while (nums[right] === nums[right + 1]) right--;
        } else if (sum < target) left++;
        else if (sum > target) right--;
      }
    }
  }
  return res;
};
```

# 字符串
## 反转字符串
[反转字符串](https://leetcode.cn/problems/reverse-string/)
### 解题思路
左右指针，两两交换位置，再向中间移动
### 代码
```js
var reverseString = function (s) {
  let left = 0;
  let right = s.length - 1;
  while (left < right) {
    [s[left], s[right]] = [s[right], s[left]];
    left++;
    right--;
  }
  return s;
};
//另外一种写法
var reverseString = function(s) {
    const n = s.length;
  	//双指针不断交换left和right位置的元素
    for (let left = 0, right = n - 1; left < right; left++, right--) {
        [s[left], s[right]] = [s[right], s[left]];
    }
};
作者：晨
链接：https://leetcode.cn/problems/reverse-string/

```
## 反转字符串Ⅱ
[反转字符串Ⅱ](https://leetcode.cn/problems/reverse-string-ii/)
### 题目思路
首先,要将==字符串转为数组==，一开始没考虑到
其次，取每个2k 长的字符中小于等于 k 长度的字符进行反转
 需要注意的是右指针可能会超过数组长度，需要进行判断
最后，将反转好的数组转为字符串
### 代码
```js
var reverseStr = function (s, k) {
  let arr = s.split("");
  const len = arr.length;
  for (let i = 0; i < len; i += 2 * k) {
    let left = i;
    let right = Math.min(left + k - 1, len - 1);
    while (left < right) {
      [arr[left], arr[right]] = [arr[right], arr[left]];
      left++;
      right--;
    }
  }
  return arr.join("");
};
```

## 替换数字
法1：Map 遍历+正则
```js

var __readline = require("readline-sync");
__readline.setDefaultOptions({ prompt: "" });
var readline = __readline.prompt;

let input = readline();

// 将字符串拆分为字符数组
const arr = input.split("");

// 使用 map 方法遍历数组并进行映射
const arr1 = arr.map((i) => {
  // 使用正则表达式检查是否是 1 到 9 之间的数字
  return /[1-9]/.test(i) ? "number" : i;
});

// 将数组拼接为字符串并输出
console.log(arr1.join(""));
```
法2：自己写的
```js
let input = readline();
arr = input.split("");
arr1 = [];
for (let i of arr) {
  if (i in [1, 2, 3, 4, 5, 6, 7, 8, 9]) {
    arr1.push("number");
  } else {
    arr1.push(i);
  }
}
arr1.join("");
console.log(arr1.join(""));
```
条件可以进行更换
```js
const readline=require("readline");
const rl=readline.createInterface({
    input:process.stdin,
    output:process.stdout
});
rl.on("line",(input)=>{
    let inputArr=input.split("");
    let newstr="";
    for (let i = 0; i < inputArr.length; i++) {
        if(inputArr[i]>="0" && inputArr[i]<="9"){
            newstr+="number"
        }else{
            newstr+=input[i]
        }
    }
    console.log(newstr);
    rl.close();
});
```
> [!NOTE] 遍历对象 or 数组
> 遍历对象的同时修改内容，可以使用 `arr.map((i)=>{表达式})`


> [!NOTE] 比较字符串
> 在 JavaScript 中，比较字符串时是逐字符比较它们的 Unicode 码点值。对于字符串 `"1" > "0"`，实际上是比较字符 `'1'` 和 `'0'` 的 Unicode 码点值。
Unicode 码点值是一种用于表示字符的数字标识。在 Unicode 中，数字字符的码点值是按顺序递增的，因此字符 `'1'` 的码点值大于字符 `'0'`，所以表达式 `"1" > "0"` 返回 `true`。
对于字符串 `"1" > "a"`，同样是逐字符比较 Unicode 码点值。在 Unicode 中，数字字符的码点值通常小于字母字符，因此字符 `'1'` 的码点值要小于字符 `'a'`，所以表达式 `"1" > "a"` 返回 `false`。

## 反转字符串中的单词
[反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/description/)
### 代码:
#### 法一 : 双指针
```js
var reverseWords = function (s) {
  // 1. 去除字符串首尾的空格
  let str = s.trim();
  const len = str.length;
  let i = 0;
  let j = 0;
  let res = [];

  // 2. 遍历字符串
  while (j < len) {
    // 3. 找到一个单词的末尾后的空格）
    while (str[j] !== " " && j < len) j++;
    // 4. 将找到的单词插入到结果数组的开头
    res.unshift(str.slice(i, j));
    // 5. 跳过空格，找到下一个单词的起始位置
    while (str[j] == " " && j < len) j++;
    // 6. 更新起始位置
    i = j;
  }
  // 7. 返回翻转后的单词数组，并转为字符串
  return res.join(“ ”);
};
```
需要考虑的是 j 到字符串末尾的时候，j=len-1; 但最后一个字符不是空，需要再加1，然后退出循环靠就 j<len 的条件，使得 j=len 停下。

> [!NOTE] 注意点
`str.slice(i,j)` 返回索引 i 到 j-1的子字符串

#### 法二 : 分割+倒序(split+push)

```js
var reverseWords = function (s) {
  wordArray = s.split(" ");
  const len = wordArray.length;
  let res = [];
  for (let i = len - 1; i >= 0; i--) {
    if (wordArray[i] == " ") continue;
    res.push(wordArray[i]);
  }
  return res.join(" ");
};
```
## 右旋字符串-卡码网
### 法一:普通双指针
```js
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
let inputArr = [];
rl.on('line', (input) => {
  inputArr.push(input);
  if (inputArr.length === 2) {
    let para = inputArr[0];
    let str = inputArr[1];
    let arrayStr = str.split('');
    let l = 0;
    let r = l + para;
    while (r < arrayStr.length) {
      l++;
      r++;
    }
    let arr1 = str.slice(l, r);
    let arr2 = str.slice(0, l);
    let newArrayStr = arr1 + arr2;
    console.log(newArrayStr);
    rl.close();
  }
});
```
### 多次反转


## strStr() 子字符串匹配
[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

### 代码
```js
var strStr = function(haystack, needle) {
    return haystack.indexOf(needle)
};
```

```js
var strStr = function(haystack, needle) {
    return haystack.search(needle)
};
```

```js
var strStr = function (haystack, needle) {
    if (needle === "") return 0
    for (var i = 0; i < haystack.length; i++) {
        if (haystack[i] === needle[0]) {
            if (haystack.substring(i, i + needle.length) === needle) return i;
        }
    }
    return -1
};

```
## 重复的子字符串
### 题目
给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。
[重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/description/)

### 代码
1. 法一:判断是否可以由字符串的重复构成
```js
const repeatedSubstringPattern = (s) => {
  // 1. 设置 s 的长度 length
  const length = s.length;

  // 2. 设置每次累加的长度
  let str = '';

  // 3. 遍历字符串
  for (let i = 0; i < s.length - 1; i++) {
    // 3.1 累加字符串
    substr += s[i];
    // 3.2 判断是否为重复的长度
    if (s === substr.repeat(Math.floor(length / str.length))) {
      return true;
    }
  }
  // 4. 如果不存在，则返回 false
  return false;
};
作者：小鸡炖蘑菇
```
- 主要用到了 substr.repeat(nums)的函数
- 注意点:不可遍历完整个字符串,遍历到最长的字符串 `i < s.length - 1

# 双指针法
## 移除元素
### 题目
给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
[27.移除元素](https://leetcode.cn/problems/remove-element/description/)
### 思路 &&代码
参考[笨猪爆破组](https://leetcode.cn/problems/remove-element/solutions/274185/javascript-si-chong-fang-fa-you-xian-zhang-wo-qian/)
#### 法一:左右指针顺序
- 遇到不同于 val 的项，就将它直接覆盖到 nums 数组中，从第一项开始覆盖
- 遍历完数组，不同于 val 的项都安排到了 nums 数组的前头
```js
var removeElement = function (nums, val) {
  let slow = 0;
  for (let fast = 0; fast < nums.length; fast++) {
    if (nums[fast] != val) {
      nums[slow] = nums[fast];
      slow++;
    }
  }
  return slow;
};
```

#### 法二:双指针首尾项
- 指向头尾的双指针
- 遇到等于 val 的项，就拿数组的末尾项覆盖它
- 末尾项搬到前面来了，将尾指针左移一位
- 如果遇到不同于 val 的项，左指针就+1，考察下一项
- 循环结束的条件是两个指针交叉相遇
```js
var removeElement = (nums, val) => {
  let index = 0, last = nums.length - 1
  while (index <= last) {
    if (nums[index] === val) {
      nums[index] = nums[last]
      last--
    } else {
      index++
    }
  }
  return index
}

```
## 反转字符串
### 题目
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
[344. 反转字符串](https://leetcode.cn/problems/reverse-string/description/)
### 思路&&代码
#### 直接 reverse
```js
var reverseString = function (s) {
    s.reverse();
};
```
#### 左右指针
```js
var reverseString = function (s) {
  let left = 0;
  let right = s.length - 1;
  while (left < right) {
    [s[left], s[right]] = [s[right], s[left]];
    left++;
    right--;
  }
  console.log(s);
};
```
